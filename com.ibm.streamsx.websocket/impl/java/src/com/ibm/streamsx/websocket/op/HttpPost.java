/* Generated by Streams Studio: March 18, 2020 at 4:13:29 PM EDT */
/*
==============================================
# Licensed Materials - Property of IBM
# Copyright IBM Corp. 2020, 2023
==============================================
*/

/*
==================================================================
First created on: Mar/15/2020
Last modified on: Oct/04/2023

This Java operator is an utility operator available in the
streamsx.websocket toolkit. It can be used to do HTTP(S) post of
plain text or JSON or XML data or binary data. 
It can be used to test the HTTP/HTTPS text/binary data send/receive  
feature of the streamsx.websocket::WebSocketSource operator. HTTP POST is
the predominant use case for this operator. However, it also allows
HTTP GET and HTTP PUT when needed. Please read the operator 
documentation for more details.

If you see a fit, you can also use this operator for similar 
needs in your own applications.

This is a very simple implementation without too many
bells and whistles so that it is easier to use in SPL applications.
This operator can do the HTTPS (TLS a.k.a SSL) POST at a faster rate 
(200 posts per second). For the HTTP (non-TLS) POST, this utility 
Java operator can give a post rate of 1500 per second. 

If you observe either a missing or an empty 
streamsx.websocket/com.ibm.streamsx.websocket/impl/java/bin directory, 
then you should run `ant all` from the 
streamsx.websocket/com.ibm.streamsx.websocket directory. 
That will compile this HttpPost Java operator.

In the absence of a real web server, you can direct your 
(non-confidential) test data traffic from this operator to this 
site to check your HTTP POST headers and content (webhook.site). 
You can learn more about it at this URL: https://simonfredsted.com/1583

TLS trust store and keystore creation (Java related) links:
https://docs.oracle.com/cd/E19509-01/820-3503/ggfgo/index.html
==================================================================
*/
package com.ibm.streamsx.websocket.op;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.net.ssl.SSLContext;
import org.apache.http.conn.ssl.NoopHostnameVerifier;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.TrustAllStrategy;
import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.ssl.SSLContextBuilder;
import org.apache.http.ssl.SSLContexts;

import org.apache.http.HttpEntity;
import org.apache.http.NameValuePair;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.Header;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.StringEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;
import org.apache.http.entity.mime.HttpMultipartMode;
import org.apache.http.util.EntityUtils;
import org.apache.log4j.Logger;

import com.ibm.streams.operator.AbstractOperator;
import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.OperatorContext.ContextCheck;
import com.ibm.streams.operator.OutputTuple;
import com.ibm.streams.operator.StreamSchema;
import com.ibm.streams.operator.Attribute;
import com.ibm.streams.operator.StreamingData.Punctuation;
import com.ibm.streams.operator.StreamingInput;
import com.ibm.streams.operator.StreamingOutput;
import com.ibm.streams.operator.Tuple;
import com.ibm.streams.operator.Type;
import com.ibm.streams.operator.compile.OperatorContextChecker;
import com.ibm.streams.operator.model.InputPortSet;
import com.ibm.streams.operator.model.InputPortSet.WindowMode;
import com.ibm.streams.operator.model.InputPortSet.WindowPunctuationInputMode;
import com.ibm.streams.operator.model.InputPorts;
import com.ibm.streams.operator.model.Libraries;
import com.ibm.streams.operator.model.OutputPortSet;
import com.ibm.streams.operator.model.OutputPortSet.WindowPunctuationOutputMode;
import com.ibm.streams.operator.model.OutputPorts;
import com.ibm.streams.operator.model.Parameter;
import com.ibm.streams.operator.model.PrimitiveOperator;
import com.ibm.streams.operator.types.RString;
import com.ibm.streams.operator.types.ValueFactory;
import com.ibm.streams.operator.metrics.Metric;
import com.ibm.streams.operator.metrics.Metric.Kind;
import com.ibm.streams.operator.model.CustomMetric;

/**
 * Class for an operator that receives a tuple and then optionally submits a tuple. 
 * This pattern supports one or more input streams and one or more output streams. 
 * <P>
 * The following event methods from the Operator interface can be called:
 * </p>
 * <ul>
 * <li><code>initialize()</code> to perform operator initialization</li>
 * <li>allPortsReady() notification indicates the operator's ports are ready to process and submit tuples</li> 
 * <li>process() handles a tuple arriving on an input port 
 * <li>processPuncuation() handles a punctuation mark arriving on an input port 
 * <li>shutdown() to shutdown the operator. A shutdown request may occur at any time, 
 * such as a request to stop a PE or cancel a job. 
 * Thus the shutdown() may occur while the operator is processing tuples, punctuation marks, 
 * or even during port ready notification.</li>
 * </ul>
 * <p>With the exception of operator initialization, all the other events may occur concurrently with each other, 
 * which lead to these methods being called concurrently by different threads.</p> 
 */
@PrimitiveOperator(name="HttpPost", namespace="com.ibm.streamsx.websocket.op",
description=HttpPost.DESC)
@InputPorts({@InputPortSet(description=
"Every incoming tuple must have an `rstring strData` attribute whose text content (Plain text or XML or JSON) or " +
"a `blob blobData` attribute whose binary content that needs to be sent as the HTTP(S) PUT or POST payload. " +
"So, one of the input tuple's attributes should be of type `rstring` carrying the text payload if any to be sent, " +
"another attribute should be of type `blob` carrying the binary payload if any to be sent and another " +
"attribute should be `map<rstring, rstring> requestHeaders` populated with any application-specific custom " +
"HTTP request headers to be sent to the remote web server. These three are mandatory " +
"attributes that must be present in the input tuple not necessarily in any particular positional order. " + 
"In addition, it can optionally have the following two attributes: " + 
"`rstring httpMethod` that can either have GET or PUT or POST as the HTTP request activity to be performed. " +
"`rstring urlQueryString` can have a well formed URL query string to be sent along with the " + 
"GET HTTP request. e-g: `company=IBM&product=Streams&specialty=Real-Time-Data-Analytics`. " +
"So, a schema for this input stream will look like this along with any other application-specific attributes: " +
"`rstring strData, blob blobData, map<rstring, rstring> requestHeaders, rstring httpMethod, rstring urlQueryString`. " + 
"Even though, a given incoming tuple must have both the rstring and blob typed data attributes, only one of them " +
"at a time can carry the data to be sent to the remote server during a given HTTP PUT or POST. " +
"If the httpMethod attribute is not present or if it has a value of an empty string, then a HTTP POST will be performed as " +
"long as strData or blobData attribute has content to be sent.", 
cardinality=1, optional=false, windowingMode=WindowMode.NonWindowed, windowPunctuationInputMode=WindowPunctuationInputMode.Oblivious), @InputPortSet(description="Optional input ports", optional=true, windowingMode=WindowMode.NonWindowed, windowPunctuationInputMode=WindowPunctuationInputMode.Oblivious)})
@OutputPorts({@OutputPortSet(description="Emits a tuple containing the HTTP POST status code, status message, response headers " + 
"and text or binary response received from the remote web server. "  +
"This tuple's schema should bec`int32 statusCode, rstring statusMessage, map<rstring, rstring> responseHeaders, rstring strData, blob blobData`. " +
"Any other matching attributes from the incoming tuple will be forwarded via the output tuple.", 
cardinality=1, optional=false, windowPunctuationOutputMode=WindowPunctuationOutputMode.Generating), @OutputPortSet(description="Optional output ports", optional=true, windowPunctuationOutputMode=WindowPunctuationOutputMode.Generating)})
@Libraries("opt/HTTPClient-4.5.14/lib/*")
public class HttpPost extends AbstractOperator {
	private CloseableHttpClient httpClient = null;
	private String url = null;
	private String contentType = "text/plain";
	private boolean logHttpPostActions  = false;
	// Impose a tiny delay in milliseconds between continuously happening non-stop 
	// HTTP POSTs at a faster pace. HTTP POST in general is not 
	// meant for that kind of high speed data exchanges. This minor delay 
	// between consecutive posts will avoid opening too many quick 
	// connections to the remote Web Server. That helps in not getting 
	// connection refused errors. You may use it as needed.
	private int delayBetweenConsecutiveHttpPosts = 0;
	private int httpTimeout = 30;
	private boolean tlsAcceptAllCertificates = false;
	private String tlsKeyStoreFile = "";
	private String tlsKeyStorePassword = "";
	private String tlsKeyPassword = "";
	private String tlsTrustStoreFile = "";
	private String tlsTrustStorePassword = "";
	// This tells us if we have to a create a persistent (Keep-Alive) HTTP connection or not.
	private boolean createPersistentHttpConnection = false;
	// Following two instance variables will control how the
	// retry attempt for a PUT, POST or GET will be done after  
	// encountering an error during that operation.
	private int maxRetryAttempts = 0;
	// Wait time is specified in Milliseconds
	private int waitTimeBetweenRetry = 2000;
	
    // Create a HTTP put or post object.
	// As of May/24/2020, this operator supports the posting of 
	// both text data and binary data.
	org.apache.http.client.methods.HttpPut httpPut = null;
	org.apache.http.client.methods.HttpPost httpPost = null;
	org.apache.http.client.methods.HttpGet httpGet = null;
	
	// It keeps a count of how many tuples get sent to this 
	// operator for processing i.e. number of times this 
	// operator's process method gets called to do a 
	// PUT, POST or GET operation.
	private long httpPostCnt = 0;
	
	private boolean httpMethodInputAttributePresent = false;
	private boolean urlQueryStringInputAttributePresent = false;
	
	private Metric nDataItemsSent;
	private Metric nDataBytesSent;
	private Metric nDataItemsReceived;
	private Metric nDataBytesReceived;
	private Metric nHttpPostFailed;
	
	private long dataBytesSent = 0;
	private long dataBytesReceived = 0;
	
    /**
     * Initialize this operator. Called once before any tuples are processed.
     * @param context OperatorContext for this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
	@Override
	public synchronized void initialize(OperatorContext context)
			throws Exception {
    	// Must call super.initialize(context) to correctly setup an operator.
		super.initialize(context);
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " initializing in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        // TODO:
        // If needed, insert code to establish connections or resources to communicate an external system or data store.
        // The configuration information for this may come from parameters supplied to the operator invocation, 
        // or external configuration files or a combination of the two.
        // Get our HTTP Client that will work with SSL connections.
        httpClient = getHttpClient(url, httpTimeout, tlsAcceptAllCertificates,
        	tlsKeyStoreFile, tlsKeyStorePassword, tlsKeyPassword,
        	tlsTrustStoreFile, tlsTrustStorePassword);
        
    	if (httpClient == null) {
    		throw new Exception("We have no valid HTTP client. So, the HttpPost operator can't proceed further.");
    	}
    	
    	// The compile-time checker method at the bottom of this file already verified the
    	// presence of the input stream attributes and their types.
    	// Let us once again check the input stream to see if we have any of the optional attributes.
    	List<StreamingInput<Tuple>> lsi = context.getStreamingInputs();
    	// We can now validate the presence and type of the two optional input stream attributes.
    	// Optional input stream attribute: rstring httpMethod
    	if(lsi.get(0).getStreamSchema().getAttribute("httpMethod") != null) {
    		httpMethodInputAttributePresent = true;
    	}
    	
    	// Optional input stream attribute: rstring urlQueryString
    	if(lsi.get(0).getStreamSchema().getAttribute("urlQueryString") != null) {
    		urlQueryStringInputAttributePresent = true;
    	}
    	
    	// Let us create the HTTP request objects for PUT and POST only once and
    	// use them throughout the entire life of this operator. Because, URL is
    	// the same inside this operator across all PUT and POST requests.
		httpPut = new org.apache.http.client.methods.HttpPut(url); 
    	httpPost = new org.apache.http.client.methods.HttpPost(url); 
    	// For GET, we will create a request object here for now.
    	// However, we have to create it as needed in the GET logic later 
    	// depending on whether the URL contains query string or not.
    	httpGet = new org.apache.http.client.methods.HttpGet(url);
	} // End of initialize method.

    /**
     * Notification that initialization is complete and all input and output ports 
     * are connected and ready to receive and submit tuples.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public synchronized void allPortsReady() throws Exception {
    	// This method is commonly used by source operators. 
    	// Operators that process incoming tuples generally do not need this notification. 
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " all ports are ready in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
    }

	private static CloseableHttpClient getHttpClient(String myUrl, 
		int httpTimeout, boolean tlsAcceptAllCertificates,
		String tlsKeyStoreFile, String tlsKeyStorePassword, String tlsKeyPassword,
    	String tlsTrustStoreFile, String tlsTrustStorePassword) 
    	throws NoSuchAlgorithmException, KeyManagementException, 
    	KeyStoreException, CertificateException, IOException, 
    	UnrecoverableKeyException {
        // Let us customize these three settings seconds for our HTTP POST client.
    	// This will be used for these three settings,
    	// connect timeout: When a connection is established.
    	// connection request timeout: When requesting a connection from the connection manager.
    	// socket timeout: timeout for waiting for data or put differently, 
		// a maximum period inactivity between two consecutive data packets.
		// You can read more about it from here.
		// https://www.baeldung.com/httpclient-timeout
    	RequestConfig requestConfig = RequestConfig.custom().
			setConnectTimeout(httpTimeout * 1000).
			setConnectionRequestTimeout(httpTimeout * 1000).
			setSocketTimeout(httpTimeout * 1000).build(); 

    	// Get either a plain or secure HTTP client for a given URL.
        // We will create a plain HTTP client if the URL has no https: at the beginning.
        if (myUrl.indexOf("https:") != 0) {
        	System.out.println("getHttpClient-->non-TLS: Configuring now for a non-TLS HTTP client."); 
        	// URL doesn't start with https: and we can create a plain HTTP client with no SSL support.
        	CloseableHttpClient myHttpClient = HttpClientBuilder.create().setDefaultRequestConfig(requestConfig).build();
        	return myHttpClient;
        }

        // We have an https: URL which needs a TLS connection to the server.
    	// Get the SSL default context and the default protocols.
        SSLContext sslDefaultContext = SSLContext.getDefault();
        String[] sslDefaultProtocols = sslDefaultContext.getDefaultSSLParameters().getProtocols();  
        SSLConnectionSocketFactory socketFactory = null;        
    	
        if(tlsAcceptAllCertificates == true) {
        	// If user configured to accept all certificates, configure the SSL socket factory for that.
        	System.out.println("getHttpClient-->TLS: Configuring now to accept all server certificates.");
            SSLContextBuilder sslContextBuilder = SSLContextBuilder.create();
            sslContextBuilder = sslContextBuilder.loadTrustMaterial(null, TrustAllStrategy.INSTANCE);
            SSLContext sslContext = sslContextBuilder.build();
            // This URL has basic details:
            // https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/conn/ssl/SSLConnectionSocketFactory.html
            socketFactory = new SSLConnectionSocketFactory(sslContext, 
            	sslDefaultProtocols, null, NoopHostnameVerifier.INSTANCE);
        } else if ((tlsTrustStoreFile.equalsIgnoreCase("") == false) || 
        	(tlsKeyStoreFile.equalsIgnoreCase("") == false)) {
        	System.out.println("getHttpClient-->TLS: Configuring now to authenticate either server or client or both.");
        	// Set up trust store for server authentication.
            SSLContextBuilder sslContextBuilder = SSLContexts.custom();
            // Trust own CA and all self-signed certs
            if (tlsTrustStoreFile.equalsIgnoreCase("") == false) {
            	System.out.println("getHttpClient-->TLS: tlsTrustStoreFile=" + tlsTrustStoreFile);
            	
                if (tlsTrustStorePassword.equalsIgnoreCase("") == true) { 
                	// No trust store password configured.
                    sslContextBuilder = sslContextBuilder.loadTrustMaterial(
                		new File(tlsTrustStoreFile), null, new TrustSelfSignedStrategy());
                } else {
                    sslContextBuilder = sslContextBuilder.loadTrustMaterial(
                		new File(tlsTrustStoreFile), tlsTrustStorePassword.toCharArray(), 
                		new TrustSelfSignedStrategy());
                }
            }
            
            // Set up key store needed for client authentication.
            if (tlsKeyStoreFile.equalsIgnoreCase("") == false) {
            	System.out.println("getHttpClient-->TLS: tlsKeyStoreFile=" + tlsKeyStoreFile);
            	
                if (tlsKeyStorePassword.equalsIgnoreCase("") == true) { 
                    sslContextBuilder = sslContextBuilder.loadKeyMaterial(
                    	// No key store password configured.
                		new File(tlsKeyStoreFile), null, tlsKeyPassword.toCharArray());
                } else {
                    sslContextBuilder = sslContextBuilder.loadKeyMaterial(
                		new File(tlsKeyStoreFile), tlsKeyStorePassword.toCharArray(), 
                		tlsKeyPassword.toCharArray());
                }
            }
            
            SSLContext sslcontext = sslContextBuilder.build();
            socketFactory = new SSLConnectionSocketFactory(sslcontext, 
            	sslDefaultProtocols, null, NoopHostnameVerifier.INSTANCE);
        } else {
        	// Accept server certificates signed by well known certificate authorities.
        	System.out.println("getHttpClient-->TLS: Configuring now to accept server certificates " +
        		"signed by the well known certificate authorities");
        	SSLContextBuilder sslContextBuilder = SSLContexts.custom();
            SSLContext sslcontext = sslContextBuilder.build();
            socketFactory = new SSLConnectionSocketFactory(sslcontext, 
            	sslDefaultProtocols, null, 
            	SSLConnectionSocketFactory.getDefaultHostnameVerifier());
        } 
        
        CloseableHttpClient myHttpClient = HttpClientBuilder.create().
        	setDefaultRequestConfig(requestConfig).setSSLSocketFactory(socketFactory).build();
    	return myHttpClient;
    } // End of getHttpClient. 
    
    /**
     * Process an incoming tuple that arrived on the specified port.
     * <P>
     * Copy the incoming tuple to a new output tuple and submit to the output port. 
     * </P>
     * @param inputStream Port the tuple is arriving on.
     * @param tuple Object representing the incoming tuple.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public final void process(StreamingInput<Tuple> inputStream, Tuple tuple) throws Exception {
        // Without a valid http client, we have nothing much to do here.
    	if (httpClient == null) {
    		return;
    	}
    	
    	// If the user configured delayBetweenConsecutiveHttpPosts, let us impose that delay now.
    	if (delayBetweenConsecutiveHttpPosts > 0) {
    		try {
    			Thread.sleep(delayBetweenConsecutiveHttpPosts);
    		} catch(Exception  ex) {
    			// We can ignore any exception for this tiny sleep.
    		}
    	}
    	
    	// Create a new tuple for output port 0
        StreamingOutput<OutputTuple> outStream = getOutput(0);
        OutputTuple outTuple = outStream.newTuple();

        // Copy across all matching attributes.
        outTuple.assign(tuple);
        String httpMethod = "POST";
        
        // If the incoming tuple has an httpMethod attribute, let us read that attribute's value now.
        if(httpMethodInputAttributePresent == true) {
        	httpMethod = tuple.getString("httpMethod").toUpperCase();
        	
        	if(httpMethod.equalsIgnoreCase("GET") == false &&
        	   httpMethod.equalsIgnoreCase("PUT") == false &&
        	   httpMethod.equalsIgnoreCase("POST") == false &&
        	   httpMethod.equalsIgnoreCase("") == false) {
        	   // We only support GET, PUT and POST.
        	   // If any other http method is specified, we will ignore this input tuple.
        	   OperatorContext context = getOperatorContext();
               Logger.getLogger(this.getClass()).error("Operator " + 
        		   context.getName() + 
        		   ". Unsupported HTTP method " +  httpMethod + " is specified. " +
        		   "This input tuple is being ignored." + ": " + 
        		   context.getPE().getPEId() + 
           		   " in Job: " + context.getPE().getJobId());
               return;
        	}
        	
        	// If the httpMethod attribute is present and if it is set to 
        	// an empty string, let us put it to the default of POST.
        	if(httpMethod.equalsIgnoreCase("") == true) {
        		httpMethod = "POST";
        	}
        }

        int retryAttemptCnt = -1;
        long bytesSent = 0;
        OperatorContext context = getOperatorContext();
        
    	// Senthil added this while loop on Oct/02/2023 to support
    	// retry of PUT, POST or GET in case of any error while
    	// performing that operation. We will surround the entire
    	// logic inside a while loop. The very last statement inside 
    	// this while loop must be a break so that we will always break 
    	// from this loop in case of a successful PUT, POST or GET operation.
    	while(true) {
    		retryAttemptCnt++;
    		
    		// Check if we must retry the intended PUT, POST or GET operation.
    		if(maxRetryAttempts == 0 && retryAttemptCnt == 1) {
    			// No retry attempt count was configured for this operator instance.
    			// So, no retry attempt needed and we can exit after just making the 
    			// intended PUT, POST or GET operation once.
    			break;
    		}
    		
    		if(maxRetryAttempts > 0 && retryAttemptCnt > maxRetryAttempts) {
    			// We are done with the maximum retry attempts that was 
    			// configured for this operator instance.
    			Logger.getLogger(this.getClass()).error("Operator=" + context.getName() + ", PE=" + 
    				context.getPE().getPEId() + ", Job=" + context.getPE().getJobId() +
    				", Incoming tuple number=" + httpPostCnt + 
    				". Giving up the HTTP " + httpMethod + 
    				" operation for the current incoming tuple after making " + 
    				maxRetryAttempts + " retry attempts.");
    			break;
    		}
    		
    		if(maxRetryAttempts > 0 && retryAttemptCnt > 0) {
    			// We are now retrying the PUT, POST or GET operation.
    			// Wait if needed before the retry attempt.
    			if (waitTimeBetweenRetry > 0) {
    				try {
    					Thread.sleep(waitTimeBetweenRetry);
    				} catch(Exception  ex) {
    					// We can ignore any exception for this tiny sleep.
    				}
    			}
    			
    			// Write a log entry about the retry attempt.
    			Logger.getLogger(this.getClass()).error("Operator=" + context.getName() + ", PE=" + 
    				context.getPE().getPEId() + ", Job=" + context.getPE().getJobId() + 
    				", Incoming tuple number=" + httpPostCnt + 
    				". HTTP operation=" + httpMethod + ", Wait time between retry=" +  
    				waitTimeBetweenRetry + " msec" +
    				", Retry attempt=" + retryAttemptCnt + " of " + maxRetryAttempts + ".");
    		}
    		
	        if(httpMethod.equalsIgnoreCase("PUT") == true || 
	           httpMethod.equalsIgnoreCase("POST") == true) {
		        // ============= START OF HTTP PUT/POST PROCESSING =============
		    	if(httpMethod.equalsIgnoreCase("PUT") == true) {
			    	// At this time, the incoming tuple must have its string or 
			    	// blob PUT content in one of its attributes. 
			    	httpPut.setHeader("Content-Type", contentType);
		    	} else {
			    	// At this time, the incoming tuple must have its string or 
			    	// blob POST content in one of its attributes. 
			    	httpPost.setHeader("Content-Type", contentType);
		    	}
		    	
		        if (contentType.equalsIgnoreCase("application/x-www-form-urlencoded") == true) {
		            // If the content-type is set to application/x-www-form-urlencoded, then we will
		            // conform to the normal practice of having the request body's format as the query string.
		            // e-g: param1=value
		        	//
		        	// This particular technique about posting as query string is explained in this URL: 
		        	// https://stackoverflow.com/questions/8120220/how-to-use-parameters-with-httppost
		        	ArrayList<NameValuePair> postParameters;
		        	postParameters = new ArrayList<NameValuePair>();
		        	postParameters.add(new BasicNameValuePair("strData", tuple.getString("strData")));
		        	UrlEncodedFormEntity ue = new UrlEncodedFormEntity(postParameters, "UTF-8");
		        	
		        	if(httpMethod.equalsIgnoreCase("PUT") == true) {
		        		httpPut.setEntity(ue);
		        	} else {
		        		httpPost.setEntity(ue);
		        	}
		        	
		        	bytesSent = tuple.getString("strData").length();
		        } else if (contentType.equalsIgnoreCase("application/octet-stream") == true) {
		        	// If the content-type is set to application/octet-stream, then we will
		        	// make this operator post raw binary data passed via the blobData 
		        	// attribute in the input tuple.
		        	// Some useful links that explain the use of application/octet-stream to send
		        	// any arbitrary piece of binary data:
		        	// https://www.iana.org/assignments/media-types/application/octet-stream
		        	// https://stackoverflow.com/questions/20508788/do-i-need-content-type-application-octet-stream-for-file-download
		        	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition
		        	// This particular technique about posting binary data is explained in this URL:
		        	// https://www.baeldung.com/httpclient-multipart-upload 
		        	MultipartEntityBuilder builder = MultipartEntityBuilder.create();
		        	builder.setMode(HttpMultipartMode.BROWSER_COMPATIBLE);
		        	builder.addBinaryBody("blobData", tuple.getBlob("blobData").getData());
		        	HttpEntity entity = builder.build();
		        	
		        	if(httpMethod.equalsIgnoreCase("PUT") == true) {
		        		httpPut.setEntity(entity);
		        	} else {
		        		httpPost.setEntity(entity);
		        	}
		        	
		        	bytesSent = tuple.getBlob("blobData").getLength();
		        } else  {
			    	org.apache.http.entity.ContentType ct = 
				    	org.apache.http.entity.ContentType.create(contentType);
				    	
			    	if (ct == null) {
			            Logger.getLogger(this.getClass()).error("Operator " + 
			            	context.getName() + ", Unable to create a MIME content type object from " + 
			            	contentType + ": " + context.getPE().getPEId() + 
			            	" in Job: " + context.getPE().getJobId());
			            return;
			    	}
				    	
		        	// Any other content type that the user specified must be
		        	// related to posting text data.
		        	StringEntity se = new StringEntity(tuple.getString("strData"), ct);
		        	
		        	if(httpMethod.equalsIgnoreCase("PUT") == true) {
		        		httpPut.setEntity(se);
		        	} else {
		        		httpPost.setEntity(se);
		        	}
		        	
		        	bytesSent = tuple.getString("strData").length();
		        }
		        
		        // Set the connection close request header.
		        // We must do this for the Apache HttpClient versions greater than 4.3.6.
		        // If we don't have this header in those versions of the HttpClient, 
		        // it will give the following exception when trying to do a burst of
		        // POST data with a very little time gap between them (say 50 msecs spacing
		        // between each HTTP POST).
		        //
		        // org.apache.http.NoHttpResponseException: b0513:8080 failed to respond
		        //
		        // You can learn more about this fix from these URLs.
		        // https://stackoverflow.com/questions/29104643/httpclienterror-the-target-server-failed-to-respond
		        // https://doc.nuxeo.com/blog/using-httpclient-properly-avoid-closewait-tcp-connections/
		        // https://serverfault.com/questions/790197/what-does-connection-close-mean-when-used-in-the-response-message
		        //
		        if(httpMethod.equalsIgnoreCase("PUT") == true) {
		        	if(createPersistentHttpConnection == true) {
		        		// If user opted for a persistent HTTP connection, we can
		        		// send this header to the server. It is upto the server to honor this option.
		        		httpPut.setHeader("connection", "Keep-Alive");
		        	} else {
		        		httpPut.setHeader("connection", "close");
		        	}
		        } else {
		        	if(createPersistentHttpConnection == true) {
		        		// If user opted for a persistent HTTP connection, we can
		        		// send this header to the server. It is upto the server to honor this option.
		        		httpPost.setHeader("connection", "Keep-Alive");
		        	} else {
		        		httpPost.setHeader("connection", "close");
		        	}
		        }
		        
		        // We will now set the application-specific custom HTTP request headers if any sent via
		        // the requestHeaders attribute of the input tuple. It is of SPL type map<rstring, rstring>. 
		        // This map iteration technique is explained in the following URL. 
		        // https://www.geeksforgeeks.org/map-interface-java-examples/
		        Map<RString, RString> requestHeadersMap = 
		        	(Map<RString, RString>) tuple.getMap("requestHeaders");
		        Set<Map.Entry<RString, RString>> setView = requestHeadersMap.entrySet();
		        
		        // Set the customer HTTP request headers.
		        for(Map.Entry<RString, RString> mapEntry : setView) {
		        	if(httpMethod.equalsIgnoreCase("PUT") == true) {
		        		httpPut.setHeader(mapEntry.getKey().toString(), mapEntry.getValue().toString());
		        	} else {
		        		httpPost.setHeader(mapEntry.getKey().toString(), mapEntry.getValue().toString());
		        	}
		        }

		        if(retryAttemptCnt == 0) {
		        	// Increment it only once during the very first 
		        	// PUT or POST operation attempt for a given input tuple.
		        	// i.e. don't increment it during retry attempts.
		        	httpPostCnt++;
		        }
		        
		        if(logHttpPostActions == true) {
		        	if(httpMethod.equalsIgnoreCase("PUT") == true) {
			        	System.out.println((httpPostCnt) + 
				        	") Executing request " + httpPut.getRequestLine());	        		
		        	} else {
			        	System.out.println((httpPostCnt) + 
			        		") Executing request " + httpPost.getRequestLine());
		        	}
		        }
		
		        // Do the HTTP PUT/POST now.
		        CloseableHttpResponse response = null;
		        
		        try {
		        	if(httpMethod.equalsIgnoreCase("PUT") == true) {
		        		response = httpClient.execute(httpPut);
		        	} else {
		        		response = httpClient.execute(httpPost);
		        	}
		        	
		        	dataBytesSent += bytesSent;
		        } catch (Exception ex) {
		        	URI uri = null;
		        	
		        	if(httpMethod.equalsIgnoreCase("PUT") == true) {
		        		uri = httpPut.getURI();
		        	} else {
		        		uri = httpPost.getURI();
		        	}
		        	
		        	Logger.getLogger(this.getClass()).error("Operator " + 
		        		context.getName() + ", HTTP " + httpMethod + 
		        		" " + httpPostCnt + " failed to " + uri + ". Exception=" + 
		        		ex.getMessage() + ". PE " + context.getPE().getPEId() + 
		        		" in Job: " + context.getPE().getJobId());
		        	
		            // Release the HTTP connection which is a must after 
		            // consuming the response from the remote web server.
		            // If we don't do this, it will start hanging when doing the 
		            // next HTTP GET/PUT/POST for the next incoming  tuple.
		            if(httpMethod.equalsIgnoreCase("PUT") == true) {
		            	httpPut.releaseConnection();
		            } else {
		            	httpPost.releaseConnection();
		            }
		            
		            // Update the operator metrics.
		            nHttpPostFailed.increment();
		            
		            if(maxRetryAttempts == 0 || retryAttemptCnt == maxRetryAttempts) {
		            	// Even in the case of an exception, we will emit an
		            	// output tuple to inform the application that invoked this operator.
		            	outTuple.setInt("statusCode", 12345);
		            	outTuple.setString("statusMessage", ex.getMessage());
		            	outStream.submit(outTuple);
		            }
		            
		            // Continue the while loop to decide if we must make a 
		            // retry attempt after this PUT/POST exception.
		            continue;
		        }

		        int responseStatusCode = response.getStatusLine().getStatusCode();
		        
		        // Update the operator metrics.
		        if (responseStatusCode < 200 || responseStatusCode > 299) {
		        	nHttpPostFailed.increment();
		        } else {
		        	nDataItemsSent.increment();
		        	nDataBytesSent.setValue(dataBytesSent);
		        }
		        
		        String responseStatusReason = response.getStatusLine().getReasonPhrase();
		        // Let us now parse all the response headers and populate them in
		        // a map to be sent in the output tuple later in the code below.
		        HashMap<RString, RString> responseHeadersMap = new HashMap<RString, RString>();
		        Header[] responseHeaders = response.getAllHeaders();
		        
		        // Store the response headers in a map for later use.
		        for (Header header : responseHeaders) {
		        	responseHeadersMap.put(new RString(header.getName()), new RString(header.getValue()));
		        }
		        
		        HttpEntity resEntity = response.getEntity();
		        String responseStrData = "";
		        byte[] responseBlobData = null;
		        
		        // https://stackoverflow.com/questions/6660243/how-do-i-use-httpclient-in-java-to-retrieve-a-binary-file
		        // https://kodejava.org/how-do-i-get-entity-contenttype-in-httpclient/
		        if (resEntity != null) {
		        	// This technique is explained well in this URL:
		        	// https://kodejava.org/how-do-i-get-entity-contenttype-in-httpclient/
		        	org.apache.http.entity.ContentType contentType = 
		        		org.apache.http.entity.ContentType.getOrDefault(resEntity);
		            String mimeType = contentType.getMimeType();
		            
		            if (mimeType.equalsIgnoreCase("application/octet-stream") == true) {
		            	// It is binary based response sent by the remote web server.
		            	responseBlobData = EntityUtils.toByteArray(resEntity);
		            	dataBytesReceived += responseBlobData.length;
		            } else {
		            	// It is text based response sent by the remote web server.
		            	responseStrData = EntityUtils.toString(resEntity);
		            	dataBytesReceived += responseStrData.length();
		            	// This is string based response. So, we can safely 
		            	// clear the blobData attribute.
		            	byte[] emptyBytes = new byte[0];
		            	outTuple.setBlob("blobData", 
		                	ValueFactory.newBlob(emptyBytes, 0, 0));
		            }
		            
		            if (responseStatusCode >= 200 && responseStatusCode < 300) {
		            	// Update the metrics if it is a successful response code.
		            	nDataItemsReceived.increment();
		            	nDataBytesReceived.setValue(dataBytesReceived);
		            }
		        }
		        
		        if (resEntity != null) {
		        	EntityUtils.consume(resEntity);
		        }
		        
		        if(logHttpPostActions == true) {
		        	System.out.println((httpPostCnt) + ") Response=" + 
		        		response.getStatusLine() + " " + responseStrData);
		        }
		      
		        // We can close this response object now.
		        // https://stackoverflow.com/questions/21574478/what-is-the-difference-between-closeablehttpclient-and-httpclient-in-apache-http
		        response.close();
		        
		        // Release the HTTP connection which is a must after 
		        // consuming the response from the remote web server.
		        // If we don't do this, it will start hanging when doing the 
		        // next HTTP GET/PUT/POST for the next incoming tuple.
		        if(httpMethod.equalsIgnoreCase("PUT") == true) {
			        httpPut.releaseConnection();
		        } else {
			        httpPost.releaseConnection();
		        }
		        
		        outTuple.setInt("statusCode", responseStatusCode);
		        outTuple.setString("statusMessage", responseStatusReason);
		        outTuple.setMap("responseHeaders", responseHeadersMap);
		        outTuple.setString("strData", responseStrData);
		        
		        if(responseBlobData != null) {
		        	outTuple.setBlob("blobData", 
		        		ValueFactory.newBlob(responseBlobData, 0,
		        		responseBlobData.length));
		        }
		        
		        // If the response status code is not 200, clear the blob output attribute.
		        // Because, in case of an HTTP PUT/POST error, we want only the strData attribute to
		        // carry the error reason. In that case, we don't want any blobData auto assigned 
		        // from the input tuple. So, we can safely empty the contents if any in the 
		        // blobData attribute. This may be a redundant exercise since there is similar
		        // logic performed above when any kind of text response is received from HTTP POST.
		        // Since it is such a minimal logic here, that redundancy is something we can live with.
		        if(responseStatusCode != 200) {
		        	byte[] emptyBytes = new byte[0];
		        	outTuple.setBlob("blobData", 
		            	ValueFactory.newBlob(emptyBytes, 0, 0));
		        }
		
		        // Submit new tuple to output port 0
		        outStream.submit(outTuple);
		        // ============= END OF HTTP PUT/POST PROCESSING =============
	        } // End of if(httpMethod.equalsIgnoreCase("PUT") == true ||    
	        
	        if(httpMethod.equalsIgnoreCase("GET") == true) {
	        	// ============= START OF HTTP GET PROCESSING =============
	        	// In HTTP GET, we can only send the data via a query string as
	        	// key=value pairs. The content type application/x-www-form-urlencoded is
	        	// not applicable for HTTP GET since that particular content type is associated 
	        	// only with putting/posting data from HTML forms or in a programmatic way.
	        	String urlQueryString = "";
	
	        	if(urlQueryStringInputAttributePresent == true) {
	        		// Get the user specified URL query string value.
	        		urlQueryString = tuple.getString("urlQueryString");
	        	}
	        	
	        	if(urlQueryString.equalsIgnoreCase("") == true) {
	        		// No URL query string specified by the user.
	        		// We can use just the URL that is configured and
	        		// get a new http GET object for us to work with.
	        		httpGet = new org.apache.http.client.methods.HttpGet(url);
	        	} else {
	        		// There is a user specified URL query string. Let us create a 
	        		// new URI with a combination of the URL and the query string.
	        		// Then, we can use that URI get a new http GET object for us to work with.
	        		URIBuilder uriBuilder = new URIBuilder(url);
	        		uriBuilder = uriBuilder.setCustomQuery(urlQueryString);
	        		URI uri = uriBuilder.build();
	        		httpGet = new org.apache.http.client.methods.HttpGet(uri);
	        	}
	        	
		    	httpGet.setHeader("Content-Type", contentType);
		    	bytesSent = urlQueryString.length();
		        
		        // Set the connection close request header.
		        // We must do this for the Apache HttpClient versions greater than 4.3.6.
		        // If we don't have this header in those versions of the HttpClient, 
		        // it will give the following exception when trying to do a burst of
		        // GET/PUT/POST data with a very little time gap between them (say 50 msecs spacing
		        // between each HTTP GET/PUT/POST).
		        //
		        // org.apache.http.NoHttpResponseException: b0513:8080 failed to respond
		        //
		        // You can learn more about this fix from these URLs.
		        // https://stackoverflow.com/questions/29104643/httpclienterror-the-target-server-failed-to-respond
		        // https://doc.nuxeo.com/blog/using-httpclient-properly-avoid-closewait-tcp-connections/
		        // https://serverfault.com/questions/790197/what-does-connection-close-mean-when-used-in-the-response-message
		        //
		        // For GET, we will not do persistent connections even if the user opted for it.
		        // Because, it is not clear whether persistent connection brings us a great benefit as 
		        // GET URLs can keep changing with new query strings. So, we will always send this header.
		        // httpGet.setHeader("connection", "close");
	        	if(createPersistentHttpConnection == true) {
	        		// If user opted for a persistent HTTP connection, we can
	        		// send this header to the server. It is upto the server to honor this option.
	        		httpGet.setHeader("connection", "Keep-Alive");
	        	} else {
	        		httpGet.setHeader("connection", "close");
	        	}
		        
		        // We will now set the application-specific custom HTTP request headers if any sent via
		        // the requestHeaders attribute of the input tuple. It is of SPL type map<rstring, rstring>. 
		        // This map iteration technique is explained in the following URL. 
		        // https://www.geeksforgeeks.org/map-interface-java-examples/
		        Map<RString, RString> requestHeadersMap = 
		        	(Map<RString, RString>) tuple.getMap("requestHeaders");
		        Set<Map.Entry<RString, RString>> setView = requestHeadersMap.entrySet();
		        
		        // Set the customer HTTP request headers.
		        for(Map.Entry<RString, RString> mapEntry : setView) {
		        	httpGet.setHeader(mapEntry.getKey().toString(), mapEntry.getValue().toString());
		        }
		        
		        if(retryAttemptCnt == 0) {
		        	// Increment it only once during the very first 
		        	// GET operation attempt for a given input tuple.
		        	// i.e. don't increment it during retry attempts.
		        	httpPostCnt++;
		        }
		        
		        if(logHttpPostActions == true) {
			        System.out.println((httpPostCnt) + 
				        ") Executing request " + httpGet.getRequestLine());	        		
		        }
		
		        // Do the HTTP GET now.
		        CloseableHttpResponse response = null;
		        
		        try {
		        	response = httpClient.execute(httpGet);
		        	dataBytesSent += bytesSent;
		        } catch (Exception ex) {
		        	URI uri = null;
		        	uri = httpGet.getURI();
		        	
		        	Logger.getLogger(this.getClass()).error("Operator " + 
		        		context.getName() + ", HTTP GET " + httpPostCnt + 
		        		" failed to " + uri + ". Exception=" + 
		        		ex.getMessage() + ". PE " + context.getPE().getPEId() + 
		        		" in Job: " + context.getPE().getJobId());
		        	
		        	// Release the HTTP connection which is a must after 
		        	// consuming the response from the remote web server.
		        	// If we don't do this, it will start hanging when doing the 
		        	// next HTTP GET/PUT/POST for the next incoming tuple.
		        	httpGet.releaseConnection();
		        	// Update the operator metrics.
		        	nHttpPostFailed.increment();
		            
		        	if(maxRetryAttempts == 0 || retryAttemptCnt == maxRetryAttempts) {
		        		// Even in the case of an exception, we will emit an
		        		// output tuple to inform the application that invoked this operator.
		        		outTuple.setInt("statusCode", 12345);
		        		outTuple.setString("statusMessage", ex.getMessage());
		        		outStream.submit(outTuple);
		        	}

		        	// Continue the while loop to decide if we must make a 
		        	// retry attempt after this GET exception.
		        	continue;
		        }
		                
		        int responseStatusCode = response.getStatusLine().getStatusCode();
		        
		        // Update the operator metrics.
		        if (responseStatusCode < 200 || responseStatusCode > 299) {
		        	nHttpPostFailed.increment();
		        } else {
		        	nDataItemsSent.increment();
		        	nDataBytesSent.setValue(dataBytesSent);
		        }
		        
		        String responseStatusReason = response.getStatusLine().getReasonPhrase();
		        // Let us now parse all the response headers and populate them in
		        // a map to be sent in the output tuple later in the code below.
		        HashMap<RString, RString> responseHeadersMap = new HashMap<RString, RString>();
		        Header[] responseHeaders = response.getAllHeaders();
		        
		        // Store the response headers in a map for later use.
		        for (Header header : responseHeaders) {
		        	responseHeadersMap.put(new RString(header.getName()), new RString(header.getValue()));
		        }
		        
		        HttpEntity resEntity = response.getEntity();
		        String responseStrData = "";
		        byte[] responseBlobData = null;
		        
		        // https://stackoverflow.com/questions/6660243/how-do-i-use-httpclient-in-java-to-retrieve-a-binary-file
		        // https://kodejava.org/how-do-i-get-entity-contenttype-in-httpclient/
		        if (resEntity != null) {
		        	// This technique is explained well in this URL:
		        	// https://kodejava.org/how-do-i-get-entity-contenttype-in-httpclient/
		        	org.apache.http.entity.ContentType contentType = 
		        		org.apache.http.entity.ContentType.getOrDefault(resEntity);
		            String mimeType = contentType.getMimeType();
		            
		            if (mimeType.equalsIgnoreCase("application/octet-stream") == true) {
		            	// It is binary based response sent by the remote web server.
		            	responseBlobData = EntityUtils.toByteArray(resEntity);
		            	dataBytesReceived += responseBlobData.length;
		            } else {
		            	// It is text based response sent by the remote web server.
		            	responseStrData = EntityUtils.toString(resEntity);
		            	dataBytesReceived += responseStrData.length();
		            	// This is string based response. So, we can safely 
		            	// clear the blobData attribute.
		            	byte[] emptyBytes = new byte[0];
		            	outTuple.setBlob("blobData", 
		                	ValueFactory.newBlob(emptyBytes, 0, 0));
		            }
		            
		            if (responseStatusCode >= 200 && responseStatusCode < 300) {
		            	// Update the metrics if it is a successful response code.
		            	nDataItemsReceived.increment();
		            	nDataBytesReceived.setValue(dataBytesReceived);
		            }
		        }
		        
		        if (resEntity != null) {
		        	EntityUtils.consume(resEntity);
		        }
		        
		        if(logHttpPostActions == true) {
		        	System.out.println((httpPostCnt) + ") Response=" + 
		        		response.getStatusLine() + " " + responseStrData);
		        }
		      
		        // We can close this response object now.
		        // https://stackoverflow.com/questions/21574478/what-is-the-difference-between-closeablehttpclient-and-httpclient-in-apache-http
		        response.close();
		        
		        // Release the HTTP connection which is a must after 
		        // consuming the response from the remote web server.
		        // If we don't do this, it will start hanging when doing the 
		        // next HTTP GET/PUT/POST for the next incoming tuple.
			    httpGet.releaseConnection();
		        
		        outTuple.setInt("statusCode", responseStatusCode);
		        outTuple.setString("statusMessage", responseStatusReason);
		        outTuple.setMap("responseHeaders", responseHeadersMap);
		        outTuple.setString("strData", responseStrData);
		        
		        if(responseBlobData != null) {
		        	outTuple.setBlob("blobData", 
		        		ValueFactory.newBlob(responseBlobData, 0,
		        		responseBlobData.length));
		        }
		        
		        // If the response status code is not 200, clear the blob output attribute.
		        // Because, in case of an HTTP POST error, we want only the strData attribute to
		        // carry the error reason. In that case, we don't want any blobData auto assigned 
		        // from the input tuple. So, we can safely empty the contents if any in the 
		        // blobData attribute. This may be a redundant exercise since there is similar
		        // logic performed above when any kind of text response is received from HTTP POST.
		        // Since it is such a minimal logic here, that redundancy is something we can live with.
		        if(responseStatusCode != 200) {
		        	byte[] emptyBytes = new byte[0];
		        	outTuple.setBlob("blobData", 
		            	ValueFactory.newBlob(emptyBytes, 0, 0));
		        }
		
		        // Submit new tuple to output port 0
		        outStream.submit(outTuple);
	        	// ============= END OF HTTP GET PROCESSING =============
	        } // End of if(httpMethod.equalsIgnoreCase("GET") == true)
	        
	        // As explained in the commentary at the start of this while loop,
	        // we must have a break statement as the very last statement within this while loop.
	        // This will allow us not to keep looping unnecessarily in case of a 
	        // successful PUT, POST or GET operation.
	        break;
    	} // End of the while loop that allows us to retry PUT, POST and GET on error.
    } // End of process method.
    
    /**
     * Process an incoming punctuation that arrived on the specified port.
     * @param stream Port the punctuation is arriving on.
     * @param mark The punctuation mark
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public void processPunctuation(StreamingInput<Tuple> stream,
    		Punctuation mark) throws Exception {
    	// For window markers, punctuate all output ports 
    	super.processPunctuation(stream, mark);
    }

    /**
     * Shutdown this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    public synchronized void shutdown() throws Exception {
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " shutting down in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        // TODO: If needed, close connections or release resources related to any external system or data store.
        // We can safely close the HTTP client.
        if(httpClient != null) {
        	// https://stackoverflow.com/questions/21574478/what-is-the-difference-between-closeablehttpclient-and-httpclient-in-apache-http
        	httpClient.close();
        }
        
        // Must call super.shutdown()
        super.shutdown();
        // Must call super.shutdown()
        super.shutdown();
    }
    
    @Parameter (name="url", description="Specify the URL to which HTTP POSTs will be sent.", optional=false)
    public void setUrl(String _url) {
    	url = _url;
    }
    
    @Parameter (name="contentType", description="Specify the MIME content type that you want. Default is text/plain.", optional=true)
    public void setContentType(String _contentType) {
    	contentType = _contentType;
    }
    
    @Parameter (name="logHttpPostActions", description="Do you want to log HTTP POST actions to the screen? (Default: false)", optional=true)
    public void setLogHttpPostActions(boolean val) {
    	logHttpPostActions = val;
    }
    
    @Parameter (name="delayBetweenConsecutiveHttpPosts", 
		description="Do you want to have a tiny delay in millseconds between consecutive HTTP Posts? (Default: 0 milliseconds i.e. no delay)", optional=true)
    public void setDelayBetweenConsecutiveHttpPosts(int val) {
    	delayBetweenConsecutiveHttpPosts = val;
    }
    
    @Parameter (name="httpTimeout", 
		description="This parameter can be used to configure the three commonly used " +
			"HTTP timeout settings namely connect, connection request and " + 
			"socket timeout all with one value. (Default: 30 seconds)", optional=true)
    public void setHttpTimeout(int val) {
    	// This will be used for these three settings,
    	// connect timeout: When a connection is established.
    	// connection request timeout: When requesting a connection from the connection manager.
    	// socket timeout: timeout for waiting for data or put differently, a maximum period inactivity between two consecutive data packets
    	httpTimeout = val;
    }
    
    @Parameter (name="tlsAcceptAllCertificates", 
		description="This parameter can be used to configure whether all TLS " +
			"certificates can be accepted with a possibility for an insecure " +
			"connection. If this parameter is set, the other two parameters " +
			"`tlsTrustStoreFile` and `tlsKeyStoreFile` are not allowed. " +
			"(Default: false)", optional=true)
    public void setTlsAcceptAllCertificates(boolean val) {
    	tlsAcceptAllCertificates = val;
    }
    
    @Parameter (name="tlsKeyStoreFile", 
		description="This parameter if present should point to a key store file in JKS format which will be " +
			"used for client authentication. This store should have client's certificate to " +
			"prove its identity. When this parameter is present, then the tlsKeyPassword " +
			"parameter must be present and the tlsKeyStorePassword can be optional.", 
			optional=true)
    public void setTlsKeyStoreFile(String val) {
    	tlsKeyStoreFile = val;
    }
    
    @Parameter (name="tlsKeyStorePassword", 
		description="This parameter specifies the password for the key store.", optional=true)
    public void setTlsKeyStorePassword(String val) {
    	tlsKeyStorePassword = val;
    }

    @Parameter (name="tlsKeyPassword", 
		description="This parameter specifies the password for the keys stored in the store.",
			optional=true)
    public void setTlsKeyPassword(String val) {
    	tlsKeyPassword = val;
    }

    @Parameter (name="tlsTrustStoreFile", 
		description="This parameter if present should point to a trust store file in JKS format which will be " +
			"used for authenticating the remote web server. This store should have server's " +
			"public certificate to verify its identity. When this parameter is present, " + 
			"then the tlsTrustStorePassword can be optional.", 
			optional=true)
    public void setTlsTrustStoreFile(String val) {
    	tlsTrustStoreFile = val;
    }
    
    @Parameter (name="tlsTrustStorePassword", 
		description="This parameter specifies the password for the trust store.", optional=true)
    public void setTlsTrustStorePassword(String val) {
    	tlsTrustStorePassword = val;
    }

    @Parameter (name="createPersistentHttpConnection", 
		description="This parameter specifies if we have to a create a persistent " +
			"(Keep-Alive) HTTP connection or not. (Default: false)", optional=true)
    public void setCreatePersistentHttpConnection(boolean val) {
    	createPersistentHttpConnection= val;
    }
      
    @Parameter (name="maxRetryAttempts", 
		description="This parameter specifies maximum retry attempts before giving up on a PUT, POST or GET operation for a given incoming tuple. Use this feature sparingly so as not to cause back pressure when this operator is processing a high volume of incoming tuples. (Default: 0 i.e. no retry attempt)", optional=true)
    public void setMaxRetryAttempts(int val) {
    	// We will not allow a negative value for this parameter.
    	if(val >= 0) {
    		maxRetryAttempts = val;
    	}
    }

    @Parameter (name="waitTimeBetweenRetry", 
		description="This parameter specifies wait time in milliseconds between retry attempts after an error on a PUT, POST or GET operation for a given incoming tuple. Use this feature sparingly so as not to cause back pressure when this operator is processing a high volume of incoming tuples. (Default: 2000 milliseconds)", optional=true)
    public void setWaitTimeBetweenRetry(int val) {
    	// We will not allow a negative value for this parameter.
    	if(val >= 0) {
    		waitTimeBetweenRetry = val;
    	}
    }
    
    public static final String DESC = "This operator posts/sends the incoming tuple's text or binary content to a " +
    		"HTTP or HTTPS persistent (Keep-Alive) or non-persistent endpoint specified in the operator parameter named url. " + 
    		"If needed, this operator can also be made to perform GET and PUT HTTP request activities as explained here. " +
    		"Every incoming tuple must have an `rstring strData` attribute whose text content (Plain text or XML or JSON) or " +
    		"a `blob blobData` attribute whose binary content that needs to be sent as the HTTP(S) PUT or POST payload. " +
    		"So, one of the input tuple's attributes should be of type `rstring` carrying the text payload if any to be sent, " +
    		"another attribute should be of type `blob` carrying the binary payload if any to be sent and another " +
    		"attribute should be `map<rstring, rstring> requestHeaders` populated with any application-specific custom " +
    		"HTTP request headers to be sent to the remote web server. These three are mandatory " +
    		"attributes that must be present in the input tuple not necessarily in any particular positional order. " + 
    		"In addition, it can optionally have the following two attributes: " + 
    		"`rstring httpMethod` that can either have GET or PUT or POST as the HTTP request activity to be performed. " +
    		"`rstring urlQueryString` can have a well formed URL query string to be sent along with the " + 
    		"GET HTTP request. e-g: `company=IBM&product=Streams&specialty=Real-Time-Data-Analytics`. " +
    		"So, a schema for this input stream will look like this along with any other application-specific attributes: " +
    		"`rstring strData, blob blobData, map<rstring, rstring> requestHeaders, rstring httpMethod, rstring urlQueryString`. " + 
    		"Even though, a given incoming tuple must have both the rstring and blob typed data attributes, only one of them " +
    		"at a time can carry the data to be sent to the remote server during a given HTTP PUT or POST. " +
    		"If the httpMethod attribute is not present or if it has a value of an empty string, then a HTTP POST will be performed as " +
    		"long as strData or blobData attribute has content to be sent. " + 
    		"On its output port, this operator emits a tuple containing the " + 
    		"HTTP POST status code, status message, response headers, " + 
    		"text based response and binary based response received from the remote web server. "  +
    		"This output tuple's schema should be `int32 statusCode, rstring statusMessage, " +
    		"map<rstring, rstring> responseHeaders, rstring strData, blob blobData`. " +
    		"To post/send text data, users can set this operator's contentType parameter to text/plain or " + 
    		"application/xml or application/json or application/x-www-form-urlencoded. To send binary data, " +
    		"it should be set to application/octet-stream which tells this operator to use a web standard based " + 
    		"mechanism available for including multipart MIME content. This operator is mainly used to test the " + 
    		"HTTP(S) feature available in the WebSocketSource operator from the streamsx.websocket toolkit. If this " + 
    		"operator can be useful in other application scenarios, developers can use it as they see fit. " +
    		"If you observe either a missing or an empty streamsx.websocket/com.ibm.streamsx.websocket/impl/java/bin directory, " +
    		"then you should run `ant all` from the streamsx.websocket/com.ibm.streamsx.websocket directory. " + 
    		"That will compile this HttpPost Java operator.";    

    // Define the metrics for this operator.
    @CustomMetric(kind = Kind.COUNTER, description ="Number of data items sent to the remote web server.")
    public void setnDataItemsSent(Metric nDataItemsSent) {
        this.nDataItemsSent = nDataItemsSent;
    }
    
	@CustomMetric(kind = Kind.COUNTER, description ="Total number of data bytes sent to the remote remote web server.")
    public void setnDataBytesSent(Metric nDataBytesSent) {
        this.nDataBytesSent = nDataBytesSent;
    }
    
    @CustomMetric(kind = Kind.COUNTER, description ="Number of data items received from the remote web server.")
    public void setnDataItemsReceived(Metric nDataItemsReceived) {
        this.nDataItemsReceived = nDataItemsReceived;
    }

	@CustomMetric(kind = Kind.COUNTER, description ="Total number of data bytes received from the remote remote web server.")
    public void setnDataBytesReceived(Metric nDataBytesReceived) {
        this.nDataBytesReceived = nDataBytesReceived;
    }    
    
    @CustomMetric(kind = Kind.COUNTER, description ="Number of failed HTTP POSTs to the remote web server.")
    public void setnHttpPostFailed(Metric nHttpPostFailed) {
        this.nHttpPostFailed = nHttpPostFailed;
    }    

    // This method does a compile time validation for the presence of certain
    // combinations of the operator parameters.
    @ContextCheck(compile = true)
    public static void checkMethodParams(OperatorContextChecker occ) {
    	String OPER_NAME="HttpPost";
    	
    	// Let us check the input stream to see if we have the expected attributes.
    	List<StreamingInput<Tuple>> lsi = occ.getOperatorContext().getStreamingInputs();
    	occ.checkRequiredAttributes(lsi.get(0), "strData", "blobData", "requestHeaders");
    
    	// Let us now check the types of the mandatory input stream attributes.
    	occ.checkAttributeType(lsi.get(0).getStreamSchema().getAttribute("strData"), Type.MetaType.RSTRING);
    	occ.checkAttributeType(lsi.get(0).getStreamSchema().getAttribute("blobData"), Type.MetaType.BLOB);
    	occ.checkAttributeType(lsi.get(0).getStreamSchema().getAttribute("requestHeaders"), Type.MetaType.MAP);
    	
    	// Validate that the requestHeaders attribute is of type map<rstring,rstring>
    	if(lsi.get(0).getStreamSchema().getAttribute("requestHeaders").
    		getType().toString().equalsIgnoreCase("MAP:map<rstring,rstring>") == false) {
            occ.setInvalidContext("{0} operator: Input stream attribute requestHeaders must be of type map<rstring,rstring>.", 
        		new String[] {OPER_NAME});
    	}
    	
    	// We can now validate the presence and type of the two optional input stream attributes.
    	// Optional input stream attribute: rstring httpMethod
    	if(lsi.get(0).getStreamSchema().getAttribute("httpMethod") != null) {
    		// httpMethod attribute is present. Let us validate its SPL type.
    		occ.checkAttributeType(lsi.get(0).getStreamSchema().getAttribute("httpMethod"), Type.MetaType.RSTRING);
    	}
    	
    	// Optional input stream attribute: rstring urlQueryString
    	if(lsi.get(0).getStreamSchema().getAttribute("urlQueryString") != null) {
    		// urlQueryString attribute is present. Let us validate its SPL type.
    		occ.checkAttributeType(lsi.get(0).getStreamSchema().getAttribute("urlQueryString"), Type.MetaType.RSTRING);
    	}
    	
    	// Let us now validate the output stream attributes and their types.
    	List<StreamingOutput<OutputTuple>> lso = occ.getOperatorContext().getStreamingOutputs();    	
    	occ.checkRequiredAttributes(lso.get(0), "statusCode", "statusMessage", 
    		"responseHeaders", "strData", "blobData");

    	// Let us now check the types of the mandatory output stream attributes.
    	occ.checkAttributeType(lso.get(0).getStreamSchema().getAttribute("statusCode"), Type.MetaType.INT32);
    	occ.checkAttributeType(lso.get(0).getStreamSchema().getAttribute("statusMessage"), Type.MetaType.RSTRING);
    	occ.checkAttributeType(lso.get(0).getStreamSchema().getAttribute("responseHeaders"), Type.MetaType.MAP);
    	occ.checkAttributeType(lso.get(0).getStreamSchema().getAttribute("strData"), Type.MetaType.RSTRING);
    	occ.checkAttributeType(lso.get(0).getStreamSchema().getAttribute("blobData"), Type.MetaType.BLOB);

    	// Validate that the responseHeaders attribute is of type map<rstring,rstring>
    	if(lso.get(0).getStreamSchema().getAttribute("responseHeaders").
    		getType().toString().equalsIgnoreCase("MAP:map<rstring,rstring>") == false) {
            occ.setInvalidContext("{0} operator: Output stream attribute responseHeaders must be of type map<rstring,rstring>.", 
        		new String[] {OPER_NAME});
    	}
    	
    	// We will ensure that certain combination of operator parameters are specified correctly.
        Set<String> parameterNames = occ.getOperatorContext().getParameterNames();
        
        // If accept all certificates is configured, then we can't have the other two.
        occ.checkExcludedParameters("tlsAcceptAllCertificates", "tlsTrustStoreFile", "tlsKeyStoreFile");
        
        // Check if trust store file and trust store password parameters are present.
        boolean hasTrustStoreFile = parameterNames.contains("tlsTrustStoreFile");
        boolean hasTrustStorePassword = parameterNames.contains("tlsTrustStorePassword");
        
        // If trust store password is there without a trust store file, that is not allowed.
        if(hasTrustStorePassword && ! hasTrustStoreFile) {
            occ.setInvalidContext("{0} operator: You cannot give a trust store password without giving a trust store filename.", 
        		new String[] {OPER_NAME});
        }
        
        // Check if key store file and key store password parameters are present.
        boolean hasKeyStoreFile = parameterNames.contains("tlsKeyStoreFile");
        boolean hasKeyStorePassword = parameterNames.contains("tlsKeyStorePassword");
        
        // If key store password is there without a key store file, that is not allowed.
        if(hasKeyStorePassword && ! hasKeyStoreFile) {
            occ.setInvalidContext("{0} operator: You cannot give a key store password without giving a key store filename.",
            	new String[] {OPER_NAME});
        }
        
        // These two parameters are optional, we either need both to be present or neither of them
        boolean hasKeyPassword = parameterNames.contains("tlsKeyPassword");
        if(hasKeyPassword ^ hasKeyStoreFile) {
            occ.setInvalidContext("{0} operator: You can either give both key store filename and key password or " + 
            	"none of them. But, never only one of them.", new String[] {OPER_NAME});
        }
    }

}
