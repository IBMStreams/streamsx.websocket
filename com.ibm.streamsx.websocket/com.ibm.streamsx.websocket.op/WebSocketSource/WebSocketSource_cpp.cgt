/*
 ==============================================
 # Licensed Materials - Property of IBM
 # Copyright IBM Corp. 2020, 2023
 ==============================================
 */

/*
 ============================================================
 First created on: Feb/22/2020
 Last modified on: Jan/29/2023

 This particular operator (WebSocketSource) is used to
 receive either text data or binary data from one or more
 remote WebSocket and HTTP(S) POST clients. This operator relies on the
 C++ boost ASIO and websocketpp open source libraries to provide
 support for data exchange using the WebSocket protocol.
 
 Please note that this operator supports message reception via 
 both WebSocket and HTTP on plain (non_tls) as well as secure TLS endpoints.
 Users will get a two-in-one benefit from this operator.
 
 This operator can also be configured to do roundtripping i.e.
 receive text/binary data from the remote clients and then 
 return text/binary data to that same client after processing the
 received data. With this configuration, this operator can perform 
 a dual task of providing source and anaytic functions.
 
 Please be aware that the logic in this operator is driven by
 multiple threads due to the event driven nature of the 
 underlying websocketpp C++ library. So, we will be using
 mutexes as needed to safely access the shared data structures.
 
 The C++ code logic here works in conjunction with the
 operator model file (WebSocketSource.xml) and the operator
 interface C++ file (WebSocketSource_h.cgt).
 ============================================================
*/
#include <SPL/Runtime/ProcessingElement/ProcessingElement.h>

/* Additional includes go here */
// https://docs.websocketpp.org/index.html
// This operator heavily relies on the Websocket++ header only library.
// This C++11 library code does the asynchronous full duplex Websocket communication with
// the remote WebSocket client via a series of event handlers (a.k.a callback methods).
// Bulk of the logic in this operator class appears in those event handler methods below.
#include <websocketpp/config/asio.hpp>
#include <websocketpp/server.hpp>

// Necessary headers from boost.
#include <boost/algorithm/string/predicate.hpp>
#include <boost/exception/to_string.hpp>
#include <boost/thread/thread.hpp>

// Necessary headers for setting user specified TLS ciphers.
#include <openssl/ssl.h>

// For the core logic below, we will need these namespaces from websocketpp.
using websocketpp::lib::placeholders::_1;
using websocketpp::lib::placeholders::_2;
using websocketpp::lib::bind;

// Verify the input and output tuple attribute name(s) and then read the operator parameters.
// It is all done via Perl.
<%
my $numberOfOutputPorts = $model->getNumberOfOutputPorts();
print("// Number of output ports found=$numberOfOutputPorts\n");

# Check the output port 0 i.e. the first output port. 
my $strDataOutputAttributeFound = 0;
my $blobDataOutputAttributeFound = 0;
my $clientSessionIdOutput1AttributeFound = 0;
my $dataOutputAsRString = undef;
my $dataOutputAsBlob = undef;
my $clientSessionIdOutput1AsUint64 = undef;

my $outputPort1 = $model->getOutputPortAt(0);
my $outputTupleName1 = $outputPort1->getCppTupleName();
my $outputAttrs1 = $outputPort1->getAttributes();

foreach my $outputAttr (@$outputAttrs1) {
	my $outAttrName = $outputAttr->getName();
	my $outAttrType = $outputAttr->getSPLType();

	# This source operator will accept an output stream with either an attribute named
	# rstring strData or an attribute named blob blobData.
	# Users can either use just one of those two attributes or both depending on
	# whether the remote clients will send only string based data or only blob based data or both.
	if ($outAttrName eq "strData") {
		$strDataOutputAttributeFound = 1;

		if ($outAttrType eq "rstring") {
			# This tuple attribute will carry a rstring containing either the xml or JSON string based data.
			$dataOutputAsRString = 1;
		}
	}
	
	if ($outAttrName eq "blobData") {
		$blobDataOutputAttributeFound = 1;

		if ($outAttrType eq "blob") {
			# This tuple attribute will carry a blob containing binary data.
			$dataOutputAsBlob = 1;
		}
	}
	
	# uint64 clientSessionId output attribute is optional, but a must 
	# when this operator is set up to send result/response back to a remote client.
	if ($outAttrName eq "clientSessionId") {
		$clientSessionIdOutput1AttributeFound = 1;

		if ($outAttrType eq "uint64") {
			# This tuple attribute will carry the WebSocket client session Id.
			$clientSessionIdOutput1AsUint64 = 1;
		}
	}
}

if ($strDataOutputAttributeFound == 0 and $blobDataOutputAttributeFound == 0) {
	SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required output tuple attribute 'strData' or 'blobData' is missing in the first output port.");
}

if ($strDataOutputAttributeFound == 1 and !(defined($dataOutputAsRString))) {
	SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required output tuple attribute 'strData' is not of type 'rstring' in the first output port.");
}

if ($blobDataOutputAttributeFound == 1 and !(defined($dataOutputAsBlob))) {
	SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required output tuple attribute 'blobData' is not of type 'blob' in the first output port.");
}

if ($clientSessionIdOutput1AttributeFound == 1 and !(defined($clientSessionIdOutput1AsUint64))) {
	SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The output tuple attribute 'clientSessionId' is not of type 'uint64' in the first output port.");
}

# Check the output port number 1 i.e. the second output port.
# It must have an attribute named uint64 clientSessionId.
my $clientSessionIdOutput2AttributeFound = 0;
my $clientSessionIdOutput2AsUint64 = undef;

my $outputPort2 = $model->getOutputPortAt(1);
my $outputTupleName2 = $outputPort2->getCppTupleName();
my $outputAttrs2 = $outputPort2->getAttributes();

foreach my $outputAttr2 (@$outputAttrs2) {
	my $outAttrName2 = $outputAttr2->getName();
	my $outAttrType2 = $outputAttr2->getSPLType();
	
	if ($outAttrName2 eq "clientSessionId") {
		$clientSessionIdOutput2AttributeFound = 1;
		
		if ($outAttrType2 eq "uint64") {
			# This tuple attribute will carry the WebSocket client session Id.
			$clientSessionIdOutput2AsUint64 = 1;
		}
	}	
}

if ($clientSessionIdOutput2AttributeFound == 0 ) {
	SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required output tuple attribute 'clientSessionId' is missing in the second output port.");
}

if (!(defined($clientSessionIdOutput2AsUint64))) {
	SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required output tuple attribute 'clientSessionId' is not of type 'uint64' in the second output port.");
}

# Even though this operator is labeled as a source, it can optionally be configured to
# function like an analytic operator. In this changed role, it will accept an input port
# to receive tuples and send them to the remote clients. In addition, this operator can
# also have another optional port to receive a client whitelist and dynamically update it
# inside this operator for allowing or rejecting connections from remote clients.
# Read the SPLDoc or the GitHub documentation to understand more.
# Important point is that these two ports can be present or completely absent or only one of
# them present. Since both of them are optional input ports, we cannot impose strict
# ordering between them. So, we must detect here automatically which port is which.
#
my $numberOfInputPorts = $model->getNumberOfInputPorts();
print("// Number of input ports found=$numberOfInputPorts\n");
# Let us see if there is a first input port specified for this operator.
my $strDataInputAttributeFound = 0;
my $blobDataInputAttributeFound = 0;
my $clientSessionIdInputAttributeFound = 0;
my $httpResponseHeadersInputAttributeFound = 0;
my $clientWhitelistInputAttributeFound = 0;
my $dataInputAsRString = undef;
my $dataInputAsBlob = undef;
my $clientSessionIdInputAsUint64 = undef;
my $httpResponseHeadersInputAsMapOfRStringAndRstring = undef;
my $clientWhitelistAsListOfRString = undef;
my $dataResponseToClientPortFound = undef;
my $clientWhitelistUpdatePortFound = undef;

# This operator can have a maximum of two optional input ports.
# One of those ports can be a data response port to return a response back to a client.
# The other port can be a port to dynamically update a client whitelist.
# Both of them can be asbent or either one of them can be present or both can be present.
# Those two ports can be specified in any order.
my $inputPort1 = $model->getInputPortAt(0);

if(defined($inputPort1)) {
	# We have to see if this input port represents a "data result/response port" or
	# a "dynamic client whitelist update port".
	my $inputTupleName1 = $inputPort1->getCppTupleName();
	my $inputAttrs1 = $inputPort1->getAttributes();	

	foreach my $inputAttr (@$inputAttrs1) {
		my $inAttrName = $inputAttr->getName();
		my $inAttrType = $inputAttr->getSPLType();

		# This operator will accept an input stream with either an attribute named
		# rstring strData or an attribute named blob blobData or both and an
		# attribute named uint64 clientSessionId.
		# Users can either use just one of those two data attributes or both depending on
		# whether the remote clients can receive only string based data or 
		# only blob based data or both.	But, the clientSessionId attribute is a must in 
		# this port to send either text or binary or both types of data to the remote clients.
		# Does this input port represent the "data result/response sent back to the remote client"?
		if ($inAttrName eq "strData") {
			$strDataInputAttributeFound = 1;
			
			if ($inAttrType eq "rstring") {
				# This tuple attribute will carry a rstring containing either plain text or xml or JSON string based data.
				$dataInputAsRString = 1;
			}
		}
		
		if ($inAttrName eq "blobData") {
			$blobDataInputAttributeFound = 1;
			
			if ($inAttrType eq "blob") {
				# This tuple attribute will carry a blob containing binary data.
				$dataInputAsBlob = 1;
			}
		}	
		
		# uint64 clientSessionId input attribute is a must  
		# for sending result/response back to a remote client.
		if ($inAttrName eq "clientSessionId") {
			$clientSessionIdInputAttributeFound = 1;
		
			if ($inAttrType eq "uint64") {
				# This tuple attribute will carry the WebSocket client session Id.
				$clientSessionIdInputAsUint64 = 1;
			}
		}
		
		#  map<rstring, rstring> httpResponseHeaders input attribute is optional.
		if ($inAttrName eq "httpResponseHeaders") {
			$httpResponseHeadersInputAttributeFound  = 1;
			
			if ($inAttrType eq "map<rstring,rstring>") {
				# This tuple attribute will carry the custom HTTP response headers.
				$httpResponseHeadersInputAsMapOfRStringAndRstring = 1;
			}
		}
		
		# This operator will accept an optional input stream with an 
		# attribute named list<rstring> clientWhitelist.
		# Users can use this attribute to dynamically update a new client whitelist.
		# Does this input port represent the "dynamically updated client whitelist"?
		if ($inAttrName eq "clientWhitelist") {
			$clientWhitelistInputAttributeFound = 1;
			
			if ($inAttrType eq "list<rstring>") {
				# This tuple attribute will carry a new client whitelist.
				$clientWhitelistAsListOfRString = 1;
			}
		}
	} # End of foreach my $inputAttr (@$inputAttrs1)

	if ($strDataInputAttributeFound == 1 and !(defined($dataInputAsRString))) {
		SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required input tuple attribute 'strData' is not of type 'rstring' in the first input port.");
	}

	if ($blobDataInputAttributeFound == 1 and !(defined($dataInputAsBlob))) {
		SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required input tuple attribute 'blobData' is not of type 'blob' in the first input port.");
	}

	if (($strDataInputAttributeFound == 1 or $blobDataInputAttributeFound == 1) and
		($clientSessionIdInputAttributeFound == 0)){
		SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required input tuple attribute 'clientSessionId' is missing in the first input port.");
	}
	
	if ($clientSessionIdInputAttributeFound == 1 and !(defined($clientSessionIdInputAsUint64))) {
		SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required input tuple attribute 'clientSessionId' is not of type 'uint64' in the first input port.");
	}
	
	if (($strDataInputAttributeFound == 1 or $blobDataInputAttributeFound == 1) and
		($clientSessionIdInputAttributeFound == 1)){
		# First input port i.e. port 0 represents the "data result/response sent to the remote client".
		$dataResponseToClientPortFound = 0;
	}	
	
	# If it represents the "data response to client port", 
	# then ensure it does not have the client whitelist attribute.
	if(defined($dataResponseToClientPortFound) and 
	   $clientWhitelistInputAttributeFound == 1) {
		SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: 'Data response to remote client' attributes are mixed with the 'client whitelist' attribute in the first input port. It is not valid.");		
	}

	# If it represents the "data response to client port", 
	# then ensure that the first output port has its own client session id 
	# attribute which is a must to do the correlation of the correct remote client.
	if(defined($dataResponseToClientPortFound) and 
	   !(defined($clientSessionIdOutput1AsUint64))) {
		SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: Trying to use a 'data response back to a remote client' option in the first input port without having an uint64 clientSessionId attribute in the first output port. It is not valid.");		
	}
		
	if(!(defined($dataResponseToClientPortFound))) {
		# First input does not represent the "data result/response sent to the remote client".
		# In that case, it must have the "client whitelist attribute".
		if ($clientWhitelistInputAttributeFound == 0) {
			SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: Input port 1 doesn't represent any accpetable schema. You can use either the 'data response back to a remote client' or the 'client whitelist' schema.");
		}

		if (!(defined($clientWhitelistAsListOfRString))) {
			SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required input tuple attribute 'clientWhitelist' is not of type 'list<rstring>' in the first input port.");
		}
		
		# We will ensure that the client whitelist attribute is not mixed with the httpResponseHeaders attribute.
		if(defined($httpResponseHeadersInputAsMapOfRStringAndRstring)) {
			# This is not allowed.
			SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: Input tuple attributes 'clientWhitelist' and 'httpResponseHeaders' are found together in the first input port. It is not valid.");			
		}

		# We will ensure that the client whitelist attribute is not mixed with the clientSessionId attribute.
		if($clientSessionIdInputAttributeFound == 1) {
			# This is not allowed.
			SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: Input tuple attributes 'clientWhitelist' and 'clientSessionId' are found together in the first input port. It is not valid.");			
		}
		
		
		# If we made it this far, first input port i.e. port 0 represents the "client whitelist".
		$clientWhitelistUpdatePortFound = 0;
	}		
	
	# At this point, we should have one of those two identified in the first input port.
	if(!(defined($dataResponseToClientPortFound)) and
	   !(defined($clientWhitelistUpdatePortFound))) {
		SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: Neither a 'data response to client port' nor a 'client whitelist' port can be found in the first input port.");
	}
} # End of if(defined($inputPort1))

my $inputPort2 = $model->getInputPortAt(1);

if(defined($inputPort2)) {
	# There is input port 2 specified. That means, it must carry what was not
	# already identified during the inspection of input port 1 in the previous if block.
	# We have to confirm here that this port carries a different one than the 
	# other type that we already found in the input port 1.
	#
	# We have to see if input port 2 represents a "data result/response port" or
	# a "dynamic client whitelist update port".
	my $inputTupleName2 = $inputPort2->getCppTupleName();
	my $inputAttrs2 = $inputPort2->getAttributes();	
	
	foreach my $inputAttr (@$inputAttrs2) {
		my $inAttrName = $inputAttr->getName();
		my $inAttrType = $inputAttr->getSPLType();

		# If we already found the "data response to client" in the first port,
		# we will focus on finding here the "client whitelist update".
		#
		# This operator will accept an input stream with either an attribute named
		# rstring strData or an attribute named blob blobData or both and an
		# attribute named uint64 clientSessionId.
		# Users can either use just one of those two data attributes or both depending on
		# whether the remote clients can receive only string based data or 
		# only blob based data or both.	But, the clientSessionId attribute is a must in 
		# this port to send either text or binary or both types of data to the remote clients.
		# Does this input port represent the "data result/response sent back to the remote client"?
		if ($inAttrName eq "strData") {
			if(defined($dataResponseToClientPortFound)) {
				# We already found this as part of input port 1. It is not valid to duplicate it in input port 2 as well.
				SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: Input port 1 already has the 'data response to client'. So, it is invalid to declare 'strData' attribute in the input port 2.");
			}
			
			$strDataInputAttributeFound = 1;
			
			if ($inAttrType eq "rstring") {
				# This tuple attribute will carry a rstring containing either plain text or xml or JSON string based data.
				$dataInputAsRString = 1;
			}
		}
		
		if ($inAttrName eq "blobData") {
			if(defined($dataResponseToClientPortFound)) {
				# We already found this as part of input port 1. It is not valid to duplicate it input port 2 as well.
				SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: Input port 1 already has the 'data response to client'. So, it is invalid to declare 'blobData' attribute in the input port 2.");
			}
			
			$blobDataInputAttributeFound = 1;
			
			if ($inAttrType eq "blob") {
				# This tuple attribute will carry a blob containing binary data.
				$dataInputAsBlob = 1;
			}
		}	
		
		# uint64 clientSessionId output attribute is a must  
		# for sending result/response back to a remote client.
		if ($inAttrName eq "clientSessionId") {
			if(defined($dataResponseToClientPortFound)) {
				# We already found this as part of input port 1. It is not valid to duplicate it input port 2 as well.
				SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: Input port 1 already has the 'data response to client'. So, it is invalid to declare 'clientSessionId' attribute in the input port 2.");
			}			
			
			$clientSessionIdInputAttributeFound = 1;
		
			if ($inAttrType eq "uint64") {
				# This tuple attribute will carry the WebSocket client session Id.
				$clientSessionIdInputAsUint64 = 1;
			}
		}

		#  map<rstring, rstring> httpResponseHeaders input attribute is optional.
		if ($inAttrName eq "httpResponseHeaders") {
			if(defined($dataResponseToClientPortFound)) {
				# We already found this as part of input port 1. It is not valid to duplicate it input port 2 as well.
				SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: Input port 1 already has the 'data response to client'. So, it is invalid to declare 'httpResponseHeaders' attribute in the input port 2.");
			}
			
			$httpResponseHeadersInputAttributeFound  = 1;
			
			if ($inAttrType eq "map<rstring,rstring>") {
				# This tuple attribute will carry the custom HTTP response headers.
				$httpResponseHeadersInputAsMapOfRStringAndRstring = 1;
			}
		}
		
		# This operator will accept an optional input stream with an 
		# attribute named list<rstring> clientWhitelist.
		# Users can use this attribute to "dynamically update a new client whitelist".
		# Does this input port represent the "dynamically updated client whitelist"?
		if ($inAttrName eq "clientWhitelist") {
			if(defined($clientWhitelistUpdatePortFound)) {
				# We already found this as part of input port 1. It is not valid to duplicate it input port 2 as well.
				SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The input tuple attribute 'clientWhitelist' is already there in port 1. It is invalid to declare it again in the input port 2.");
			}	
			
			$clientWhitelistInputAttributeFound = 1;
			
			if ($inAttrType eq "list<rstring>") {
				# This tuple attribute will carry a new client whitelist.
				$clientWhitelistAsListOfRString = 1;
			}
		}
	} # End of foreach my $inputAttr (@$inputAttrs2)
	
	# If we already found "client whitelist update" in port 1, let us now validate the other type here in port 2.
	if(defined($clientWhitelistUpdatePortFound)) {
		if ($strDataInputAttributeFound == 1 and !(defined($dataInputAsRString))) {
			SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required input tuple attribute 'strData' is not of type 'rstring' in the second input port.");
		}
	
		if ($blobDataInputAttributeFound == 1 and !(defined($dataInputAsBlob))) {
			SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required input tuple attribute 'blobData' is not of type 'blob' in the second input port.");
		}

		if (($strDataInputAttributeFound == 1 or $blobDataInputAttributeFound == 1) and
			($clientSessionIdInputAttributeFound == 0)){
			SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required input tuple attribute 'clientSessionId' is missing in the second input port.");
		}		
		
		if ($clientSessionIdInputAttributeFound == 1 and !(defined($clientSessionIdInputAsUint64))) {
			SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required input tuple attribute 'clientSessionId' is not of type 'uint64' in the second input port.");
		}
	
		if (($strDataInputAttributeFound == 1 or $blobDataInputAttributeFound == 1) and
			($clientSessionIdInputAttributeFound == 1)){
			# Second input port i.e. port 1 represents the "data result/response sent to the remote client".
			$dataResponseToClientPortFound = 1;
		}	
			
		# If it represents the "data response to client port", 
		# then ensure that the first output port has its own client session id 
		# attribute which is a must to do the correlation of the correct remote client.
		if(defined($dataResponseToClientPortFound) and 
		   !(defined($clientSessionIdOutput1AsUint64))) {
			SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: Trying to use a 'data response back to a remote client' option in the second input port without having an uint64 clientSessionId attribute in the first output port. It is not valid.");		
		}

		# At this point, we should have identified the "data response to client port".
		# If not, that is an error.
		if(!defined($dataResponseToClientPortFound)) {
			SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: Second input port is not valid. It is possibly missing a 'Data response back to a remote client' port which can be allowed there.");		
		}
	} else {
		# If we reach here, it must have the "client whitelist" attribute.
		if ($clientWhitelistInputAttributeFound == 0) {
			SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required input tuple attribute 'clientWhitelist' is missing in the second input port.");
		}
		
		if (!(defined($clientWhitelistAsListOfRString))) {
			SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: The required input tuple attribute 'clientWhitelist' is not of type 'list<rstring>' in the second input port.");
		}
		
		# If we made it this far, second input port i.e. port 1 represents the "client whitelist".
		$clientWhitelistUpdatePortFound = 1;
	} # End of if(defined($clientWhitelistUpdatePortFound))
		
	# At this point, we should have identified both of them in our 
	# two inut ports appearing in any order.
	if(!(defined($dataResponseToClientPortFound)) or
	   !(defined($clientWhitelistUpdatePortFound))) {
		SPL::CodeGen::exitln("WebSocketSource_cpp.cgt: Second input port is not valid. Either a'data response to client port' or a 'client whitelist' port is missing in the input to this operaor.");
	}
} # End of if(defined($inputPort2))
	
# Following are the operator parameters.
my $tlsPort = $model->getParameterByName("tlsPort");
# Default: 443
$tlsPort = $tlsPort ? $tlsPort->getValueAt(0)->getCppExpression() : 443;

my $tlsCipherWhitelist = $model->getParameterByName("tlsCipherWhitelist");
# Default: Empty string
$tlsCipherWhitelist = $tlsCipherWhitelist ? $tlsCipherWhitelist->getValueAt(0)->getCppExpression() : "";

my $certificateFileName = $model->getParameterByName("certificateFileName");
# Default: Default is to read ws-server.pem from the etc sub-directory of the application.
$certificateFileName = $certificateFileName ? $certificateFileName->getValueAt(0)->getCppExpression() : "";

my $certificatePassword = $model->getParameterByName("certificatePassword");
# Default: Empty string.
$certificatePassword = $certificatePassword ? $certificatePassword->getValueAt(0)->getCppExpression() : "";

my $trustedClientCertificateFileName = $model->getParameterByName("trustedClientCertificateFileName");
# Default: Default is an empty string i.e. no client (mutual) authentication performed.
$trustedClientCertificateFileName = $trustedClientCertificateFileName ? $trustedClientCertificateFileName->getValueAt(0)->getCppExpression() : "";

my $trustedClientX509SubjectIdentifiers = $model->getParameterByName("trustedClientX509SubjectIdentifiers");

# Default: If this parameter is defined, we will use the value of 
# this parameter in the C++ class constructor below. 
if (defined $trustedClientX509SubjectIdentifiers) {
	$trustedClientX509SubjectIdentifiers = 
		$trustedClientX509SubjectIdentifiers->getValueAt(0)->getCppExpression();
}

my $nonTlsEndpointNeeded = $model->getParameterByName("nonTlsEndpointNeeded");
# Default: 0
$nonTlsEndpointNeeded = $nonTlsEndpointNeeded ? $nonTlsEndpointNeeded->getValueAt(0)->getCppExpression() : 0;

my $nonTlsPort = $model->getParameterByName("nonTlsPort");
# Default: 80
$nonTlsPort = $nonTlsPort ? $nonTlsPort->getValueAt(0)->getCppExpression() : 80;

my $urlContextPath = $model->getParameterByName("urlContextPath");
# Default: Default is an empty list to indicate no URL context path.
# If this parameter is defined, we will use the value of 
# this parameter in the C++ class constructor below. 
if (defined $urlContextPath) {
	$urlContextPath = $urlContextPath->getValueAt(0)->getCppExpression();
}

my $initDelay = $model->getParameterByName("initDelay");
# Default: 0.0
$initDelay = $initDelay ? $initDelay->getValueAt(0)->getCppExpression() : 0.0;

my $websocketLiveMetricsUpdateNeeded = $model->getParameterByName("websocketLiveMetricsUpdateNeeded");
# Default: 1
$websocketLiveMetricsUpdateNeeded = $websocketLiveMetricsUpdateNeeded ? $websocketLiveMetricsUpdateNeeded->getValueAt(0)->getCppExpression() : 1;

my $websocketLoggingNeeded = $model->getParameterByName("websocketLoggingNeeded");
# Default: 0
$websocketLoggingNeeded = $websocketLoggingNeeded ? $websocketLoggingNeeded->getValueAt(0)->getCppExpression() : 0;

my $wsConnectionLoggingNeeded = $model->getParameterByName("wsConnectionLoggingNeeded");
# Default: 0
$wsConnectionLoggingNeeded= $wsConnectionLoggingNeeded ? $wsConnectionLoggingNeeded->getValueAt(0)->getCppExpression() : 0;

my $wsClientSessionLoggingNeeded = $model->getParameterByName("wsClientSessionLoggingNeeded");
# Default: 0
$wsClientSessionLoggingNeeded = $wsClientSessionLoggingNeeded ? $wsClientSessionLoggingNeeded->getValueAt(0)->getCppExpression() : 0;

my $websocketStaleConnectionPurgeInterval = $model->getParameterByName("websocketStaleConnectionPurgeInterval");
# Default: 0 seconds i.e. no stale connection purging by default.
$websocketStaleConnectionPurgeInterval = $websocketStaleConnectionPurgeInterval ? $websocketStaleConnectionPurgeInterval->getValueAt(0)->getCppExpression() : 0;

my $ipv6Available = $model->getParameterByName("ipv6Available");
# Default: 1
$ipv6Available = $ipv6Available ? $ipv6Available->getValueAt(0)->getCppExpression() : 1;

my $tcpNoDelay = $model->getParameterByName("tcpNoDelay");
# Default: 0
$tcpNoDelay = $tcpNoDelay ? $tcpNoDelay->getValueAt(0)->getCppExpression() : 0;

my $numberOfMessagesToReceiveBeforeAnAck = $model->getParameterByName("numberOfMessagesToReceiveBeforeAnAck");
# Default: 0
$numberOfMessagesToReceiveBeforeAnAck = $numberOfMessagesToReceiveBeforeAnAck ? $numberOfMessagesToReceiveBeforeAnAck->getValueAt(0)->getCppExpression() : 0;

my $allowHttpPost = $model->getParameterByName("allowHttpPost");
# Default: 0
$allowHttpPost = $allowHttpPost ? $allowHttpPost->getValueAt(0)->getCppExpression() : 0;

my $newDataCpuYieldTimeInSenderThread = $model->getParameterByName("newDataCpuYieldTimeInSenderThread");
# Default: 0.001 second i.e. 1 millisecond of CPU yield time inside a tight loop.
$newDataCpuYieldTimeInSenderThread = $newDataCpuYieldTimeInSenderThread ? $newDataCpuYieldTimeInSenderThread->getValueAt(0)->getCppExpression() : 0.001;

my $noDataCpuYieldTimeInSenderThread = $model->getParameterByName("noDataCpuYieldTimeInSenderThread");
# Default: 0.001 second i.e. 1 millisecond of CPU yield time inside a tight loop.
$noDataCpuYieldTimeInSenderThread = $noDataCpuYieldTimeInSenderThread ? $noDataCpuYieldTimeInSenderThread->getValueAt(0)->getCppExpression() : 0.001;

my $clientWhitelist = $model->getParameterByName("clientWhitelist");

# Default: It is an empty list to indicate no client whitelist.
# If this parameter is defined, we will use the value of 
# this parameter in the C++ class constructor below. 
if (defined $clientWhitelist) {
	$clientWhitelist = $clientWhitelist->getValueAt(0)->getCppExpression();
}

my $maxClientConnectionsAllowed = $model->getParameterByName("maxClientConnectionsAllowed");
# Default: 32 concurrent clients allowed
$maxClientConnectionsAllowed = $maxClientConnectionsAllowed ? $maxClientConnectionsAllowed->getValueAt(0)->getCppExpression() : 32;

my $responseTimeout = $model->getParameterByName("responseTimeout");
# Default: 20 seconds
$responseTimeout = $responseTimeout ? $responseTimeout->getValueAt(0)->getCppExpression() : 20;
%>

<%SPL::CodeGen::implementationPrologue($model);%>

// Constructor
MY_OPERATOR::MY_OPERATOR() {
	// Custom metrics for this operator are already defined in the operator model XML file. 
	// Hence, there is no need to explicitly create them here.
	// Simply get the custom metrics already defined for this operator. 
	// We will update the Counter kind custom metrics when the operator starts.
	// We will update the Gauge kind custom metrics only when the 
	// websocketLiveMetricsUpdateNeeded optional operator parameter is set to true.
	OperatorMetrics & opm = getContext().getMetrics();
	nClientsConnectedMetric = &opm.getCustomMetricByName(
		"nClientsConnected");
	nDataItemsReceivedFromRemoteClientsMetric = &opm.getCustomMetricByName(
		"nDataItemsReceivedFromRemoteClients");
	nDataBytesReceivedFromRemoteClientsMetric = &opm.getCustomMetricByName(
		"nDataBytesReceivedFromRemoteClients");
	nHttpMessagesReceivedFromRemoteClientsMetric = &opm.getCustomMetricByName(
		"nHttpMessagesReceivedFromRemoteClients");
	
	<% if (defined($dataResponseToClientPortFound)) { %>
	// We need these metrics only if this operator is configured with a
	// "result/response back to a client" input port.
	nDataItemsSentToRemoteClientsMetric = &opm.getCustomMetricByName(
		"nDataItemsSentToRemoteClients");
	nDataBytesSentToRemoteClientsMetric = &opm.getCustomMetricByName(
		"nDataBytesSentToRemoteClients");
	nResponseTimeoutOccurrencesMetric = &opm.getCustomMetricByName(
		"nResponseTimeoutOccurrences");
	<%}%>
	
	nTlsPortMetric = &opm.getCustomMetricByName("nTlsPort");
	nNonTlsPortNeededMetric = &opm.getCustomMetricByName("nNonTlsPortNeeded");
	nNonTlsPortMetric = &opm.getCustomMetricByName("nNonTlsPort");
	nHttpPostAllowedMetric = &opm.getCustomMetricByName("nHttpPostAllowed");
	nTimeTakenToSendMostRecentDataItemMetric = 
		&opm.getCustomMetricByName("nTimeTakenToSendMostRecentDataItem");
	nSizeOfMostRecentDataItemSentMetric = 
		&opm.getCustomMetricByName("nSizeOfMostRecentDataItemSent");
	nSizeOfMostRecentDataItemReceivedMetric = 
		&opm.getCustomMetricByName("nSizeOfMostRecentDataItemReceived");
	nTcpNoDelayMetric = &opm.getCustomMetricByName("nTcpNoDelay");

	dataInputAsRString = false;
	dataInputAsBlob = false;
	dataOutputAsRString = false;
	dataOutputAsBlob = false;
	
	// Initialize the member variables as needed from the operator parameter values read above.	
	<% if (defined($dataInputAsRString)) { %>
	dataInputAsRString = <%=$dataInputAsRString%>;
	<%}%>
	
	<% if (defined($dataInputAsBlob)) { %>
	dataInputAsBlob = <%=$dataInputAsBlob%>;
	<%}%>
	
	<% if (defined($dataOutputAsRString)) { %>
	dataOutputAsRString = <%=$dataOutputAsRString%>;
	<%}%>
	
	<% if (defined($dataOutputAsBlob)) { %>
	dataOutputAsBlob = <%=$dataOutputAsBlob%>;
	<%}%>
	
	tlsPort = <%=$tlsPort%>;
	nonTlsEndpointNeeded = <%=$nonTlsEndpointNeeded%>;
	nonTlsPort = <%=$nonTlsPort%>;
	
	// This is a list<rstring> that can have zero or more user provided URL context paths.
	<% if (defined $urlContextPath) { %>
	urlContextPath = <%=$urlContextPath%>;
	SPL::int32 numberOfContextPaths = SPL::Functions::Collections::size(urlContextPath);
	
	// We can now loop through the URL context path list and validate the
	// syntex of every given context path.
	for(SPL::int32 cnt = 0; cnt < numberOfContextPaths; cnt++) {
		// Ensure that the url context path doesn't start with a forward slash.
		// If it does, that will cause problems with the websocketpp::config::asio library in the
		// way it always carries a forward slash at the beginning of the return value for
		// the get_resource() API that we use in the validate_client method later in this file.
		// Example: https://b0513:8443/MyServices/Banking/Deposit
		// In this example, user must configure the context path as MyServices/Banking/Deposit
		// and not as /MyServices/Banking/Deposit
		//
		if(SPL::Functions::String::findFirst(urlContextPath[cnt], "/") == 0) {
			// First character of the URL context is a forward slash.
			// We are not going to allow that.
			throw std::runtime_error(
				std::string("WebSocketSource_cpp.cgt: URL context path starts with a forward slash character: ") +
				urlContextPath[cnt] + 
				std::string(" It is not valid. Please reconfigure it with a new value that doesn't start with ") +
				std::string("a forward slash character. "));		
		}				
	} // End of for loop.
	<%}%>
	
	initDelay = <%=$initDelay%>;
	websocketLiveMetricsUpdateNeeded = <%=$websocketLiveMetricsUpdateNeeded%>;
	websocketLoggingNeeded = <%=$websocketLoggingNeeded%>;
	wsConnectionLoggingNeeded = <%=$wsConnectionLoggingNeeded%>;
	wsClientSessionLoggingNeeded = <%=$wsClientSessionLoggingNeeded%>;
	websocketStaleConnectionPurgeInterval = <%=$websocketStaleConnectionPurgeInterval%>;
	ipv6Available = <%=$ipv6Available%>;
	tcpNoDelay = <%=$tcpNoDelay%>;
	numberOfMessagesToReceiveBeforeAnAck = <%=$numberOfMessagesToReceiveBeforeAnAck%>;
	
	// If this operator is configured with a "data result/response to client" input port,
	// then we will nbt allow acknowledgements after receiving certain number of messages.
	// That option is supported only when this operator works as a pure source operator.
	// If this operator is going to perform a combined source + analytics task with the 
	// presence of the "data result/response to client" input port, we will disable the
	// feature to send periodic acks to the clients. Since the application logic is 
	// able to send data to the clients via the input port, periodic acks can also be 
	// sent from within the application logic as needed.
	<% if (defined($dataResponseToClientPortFound)) { %>
		if(numberOfMessagesToReceiveBeforeAnAck > 0) {
			// Disable this feature by setting this value to 0.
			numberOfMessagesToReceiveBeforeAnAck = 0;
			SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
				"-->Channel " << boost::to_string(udpChannelNumber) <<
				"-->Since there is a 'data result/response to client' input port " <<
				"specified, this operator logic will not send automatic periodic acks to " <<
				"the clients. If needed, application logic can send any periodic acks " <<
				"on its own via the data response input port.", "Constructor");
		}	
	<%}%>
	
	allowHttpPost = <%=$allowHttpPost%>;
	
	// For string based assignment using a perl variable, it can't be
	// assigned directly to the value of that perl variable. If we do that,
	// such an assignement will result in an empty assignment due to $lit3 and
	// will lead to a compiler error. So, only for the string based copy from a
	// perl variable, the following check must be done for an empty string and
	// then it should be done as shown below.
	<% if ($tlsCipherWhitelist eq "") { %>	
	tlsCipherWhitelist = "";
	<% } else { %>
	tlsCipherWhitelist = <%=$tlsCipherWhitelist%>;
	<%}%>
	
	<% if ($certificateFileName eq "") { %>	
	certificateFileName = "";
	<% } else { %>
	certificateFileName = <%=$certificateFileName%>;
	<%}%>
	
	if (certificateFileName == "") {
		// User didn't provide a PEM file. We are going to read 
		// ws-server.pem from the etc directory of the application.
		certificateFileName = ProcessingElement::pe().getApplicationDirectory()
			+ "/etc/ws-server.pem";
	}

	<% if ($certificatePassword eq "") { %>	
	certificatePassword = "";
	<% } else { %>
	certificatePassword = <%=$certificatePassword%>;
	<%}%>	
	
	<% if ($trustedClientCertificateFileName eq "") { %>	
	trustedClientCertificateFileName = "";
	<% } else { %>
	trustedClientCertificateFileName = <%=$trustedClientCertificateFileName%>;
	<%}%>

	<% if (defined $trustedClientX509SubjectIdentifiers) { %>
	trustedClientX509SubjectIdentifiers = <%=$trustedClientX509SubjectIdentifiers%>;
	<%}%>
	
	newDataCpuYieldTimeInSenderThread = <%=$newDataCpuYieldTimeInSenderThread%>;

	if (newDataCpuYieldTimeInSenderThread < 0.0) {
		throw std::runtime_error(
			"WebSocketSource_cpp.cgt: Invalid value of " + 
			boost::to_string(newDataCpuYieldTimeInSenderThread) + " is given for the newDataCpuYieldTimeInSenderThread parameter." +
			" Valid value must be greater than or equal to 0.0.");		
	}
	
	noDataCpuYieldTimeInSenderThread = <%=$noDataCpuYieldTimeInSenderThread%>;

	if (noDataCpuYieldTimeInSenderThread < 0.0) {
		throw std::runtime_error(
			"WebSocketSource_cpp.cgt: Invalid value of " + 
			boost::to_string(noDataCpuYieldTimeInSenderThread) + " is given for the noDataCpuYieldTimeInSenderThread parameter." +
			" Valid value must be greater than or equal to 0.0.");		
	}
	
	<% if (defined $clientWhitelist) { %>
		clientWhitelist = <%=$clientWhitelist%>;
	<%}%>

	maxClientConnectionsAllowed = <%=$maxClientConnectionsAllowed%>;
	
	if (maxClientConnectionsAllowed <= 0) {
		throw std::runtime_error(
			"WebSocketSource_cpp.cgt: Invalid value of " + 
			boost::to_string(maxClientConnectionsAllowed) + " is given for the maxClientConnectionsAllowed parameter." +
			" Valid value must be greater than or equal to 0.");		
	}	
	
	responseTimeout = <%=$responseTimeout%>;
	
	// We need the following check only if there is a 
	// data response to client input port.
	<% if (defined($dataResponseToClientPortFound)) { %>	
	if (responseTimeout <= 0) {
		throw std::runtime_error(
			"WebSocketSource_cpp.cgt: Invalid value of " + 
			boost::to_string(responseTimeout) + " is given for the responseTimeout parameter." +
			" Valid value must be greater than 0.");		
	}
	<%}%>
	
	operatorPhysicalName = getContext().getName();
	// This operator is most likely not going to be in an 
	// UDP parallel region due to the need by the remote clients'  
	// need to connect to a single URL (machine name and port).
	// So, this variable here may not carry much value.
	udpChannelNumber = getContext().getChannel();
	
	SPLAPPTRC(L_ERROR, 
		"Operator " <<
		operatorPhysicalName <<
		"-->Channel " << boost::to_string(udpChannelNumber) <<
		". Following are the user configured operator parameters: "
		"tlsPort=" << tlsPort <<
		", tlsCipherWhitelist=" << tlsCipherWhitelist <<
		", certificateFileName=" << certificateFileName <<
		", certificatePassword length=" << certificatePassword.length() <<
		", trustedClientCertificateFileName=" << trustedClientCertificateFileName <<
		", trustedClientX509SubjectIdentifiers=" << trustedClientX509SubjectIdentifiers <<
		", nonTlsEndpointNeeded=" << nonTlsEndpointNeeded <<
		", nonTlsPort=" << nonTlsPort <<
		", urlContextPath=" << urlContextPath <<
		", initDelay=" << initDelay <<
		", websocketLiveMetricsUpdateNeeded=" << websocketLiveMetricsUpdateNeeded <<
		", websocketLoggingNeeded=" << websocketLoggingNeeded <<
		", wsConnectionLoggingNeeded=" << wsConnectionLoggingNeeded <<
		", wsClientSessionLoggingNeeded=" << wsClientSessionLoggingNeeded <<
		", websocketStaleConnectionPurgeInterval=" << websocketStaleConnectionPurgeInterval <<
		", ipv6Available="  << ipv6Available <<
		", tcpNoDelay=" << tcpNoDelay <<
		", numberOfMessagesToReceiveBeforeAnAck=" << numberOfMessagesToReceiveBeforeAnAck <<
		", allowHttpPost=" << allowHttpPost <<
		", newDataCpuYieldTimeInSenderThread=" << newDataCpuYieldTimeInSenderThread <<
		", noDataCpuYieldTimeInSenderThread=" << noDataCpuYieldTimeInSenderThread <<
		", clientWhitelist=" << clientWhitelist <<
		", maxClientConnectionsAllowed=" << maxClientConnectionsAllowed <<
		", responseTimeout=" << responseTimeout, "constructor");	
	
	tlsEndpointStarted = false;
	nonTlsEndpointStarted = false;
	clientSessionId = 0;
} // End of constructor

// Destructor
MY_OPERATOR::~MY_OPERATOR() {
	// Finalization code goes here
}

// Notify port readiness
void MY_OPERATOR::allPortsReady() {
	// Notifies that all ports are ready. No tuples should be submitted before
	// this. Source operators can use this method to spawn threads.
	//
	// Update the operator metric only if the user asked for a live update.
	if (websocketLiveMetricsUpdateNeeded == true) {
		// These are one time metrics that will not change during the life of an operator.
		nTlsPortMetric->setValueNoLock(tlsPort);
		nNonTlsPortNeededMetric->setValueNoLock(nonTlsEndpointNeeded);
		nNonTlsPortMetric->setValueNoLock(nonTlsPort);
		nHttpPostAllowedMetric->setValueNoLock(allowHttpPost);
		nTcpNoDelayMetric->setValueNoLock(tcpNoDelay);
	}
	
	//
	// This is a source operator. Let us create a thread.
	createThreads(1); // Create source thread
	
	// We need the following data sender thread only if there is a 
	// data response to client input port.
	<% if (defined($dataResponseToClientPortFound)) { %>
    /*
	// v1.1.1 change (Jan/29/2023)
	// No sender thread anymore starting in this release. 
	// Instead, it will just be a callable method that the
	// input tuple process method will invoke whenever there
	// is data available to be sent.
	//
    // Create a thread to periodically watch for the
    // data availability so that the text or binary data can be 
    // sent to the remote WebSocket clients.
    try {
    	auto callback1 = std::bind(&MY_OPERATOR::ws_data_sender, this);
    	boost::thread* myThread1 = new boost::thread(callback1);
    } catch(std::exception& e) {
    	SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
			"-->Channel " << boost::to_string(udpChannelNumber) <<
			"-->Exception in creating the ws_data_sender thread. " << 
			e.what(), "allPortsReady");
    	// We can't do much without this thread. Abort this operator now.
    	SPL::Functions::Utility::abort(__FILE__, __LINE__);
    }
    */
    
    // Create a thread to periodically detect any missed 
    // responses within a configured timeout period that are 
    // due from the application logic to the remote clients and 
    // perform necessary clean-up.
    try {
    	auto callback2 = std::bind(&MY_OPERATOR::ws_response_timeout_handler, this);
    	boost::thread* myThread2 = new boost::thread(callback2);
    } catch(std::exception& e) {
    	SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
			"-->Channel " << boost::to_string(udpChannelNumber) <<
			"-->Exception in creating the ws_response_timeout_handler thread. " << 
			e.what(), "allPortsReady");
    	// We can't do much without this thread. Abort this operator now.
    	SPL::Functions::Utility::abort(__FILE__, __LINE__);
    }    
    <%}%>
} // End of allPortsReady.

// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() {
	// As this operator is about to be shutdown, we will tell the 
	// WebSocket++ endpoints not to accept any more new client connections.
	if (tlsEndpointStarted == true) {
		endpoint_tls.stop_listening();
	}

	if (nonTlsEndpointStarted == true) {
		endpoint_non_tls.stop_listening();
	}

	// We must properly close the client connections that are currently active.
	// That will allow them to be closed normally on their end. Otherwise, clients will end up
	// with limbo (dangling) connections which will lead to unnecessary broken TCP or
	// unclean disconnect or timeouts in the remote end.
	// In addition, it also causes undesirable behaviors by not cleanly terminating the
	// asio run loop in the process method below.
	// So, we must go through the client connections map and 
	// close such existing active client connections in a proper way.
	// This will initiate the WebSocket closing handshake for 
	// these active client connections.
	//
	// Mutex for the safe shared accessing of the client connections map.
	SPL::AutoMutex autoMutex3(wsMutex3);
	con_map::iterator it = client_connections_map.begin();

	while (it != client_connections_map.end()) {
		websocketpp::connection_hdl hdl = it->first;
		connection_metadata & con_metadata = it->second;
		
		// Properly close the client connection now.
		std::string closeReason =
			"Normal close by streamsx.websocket due to the shutdown of the WebSocketSource operator.";
		websocketpp::lib::error_code ec;

		// This connection closing technique is discussed in these URLs:
		// https://stackoverflow.com/questions/25260852/shut-down-websocket-connection
		// https://github.com/zaphoyd/websocketpp/issues/803
		// https://mayaposch.wordpress.com/2015/09/16/creating-a-websocket-server-with-websocket/
		if(con_metadata.isTlsConnection == false) {
			endpoint_non_tls.close(hdl, websocketpp::close::status::normal,
				closeReason, ec);
		} else {
			endpoint_tls.close(hdl, websocketpp::close::status::normal,
				closeReason, ec);
		}

		it++;
	}

	// This operator is being shutdown now.
	// We can empty the following containers.
	client_connections_map.clear();
	
	// At this time, we can stop the boost ASIO run loop that
	// got started below in the process method of this source operator.
	if(iosRunLoopStarted == true) {
		// It will stop the ios run loop and make the
		// source operator thread exit. It should also help
		// in the immediate closure of the TLS and non-TLS ports.
		ios.stop();
	}
} // End of prepareToShutdown.

// Processing for source and threaded operators   
void MY_OPERATOR::process(uint32_t idx) {
	// If the user provided an initDelay parameter value,
	// then, we will do a one time wait here before doing anything else.
	if (initDelay > 0.0) {
		SPL::Functions::Utility::block (initDelay);
	}

	// Initialize this value to current time.
	// This is mainly used inside the on_message method to
	// remove any stale client connections.
	timeOfPreviousStaleConnectionRemoval = SPL::Functions::Time::getSeconds(
			SPL::Functions::Time::getTimestamp());

	// Initialize this source operator's custom metrics variables.
	nClientsConnected = 0;
	nDataBytesReceivedFromRemoteClients = 0;
	nDataItemsReceivedFromRemoteClients = 0;
	nHttpMessagesReceivedFromRemoteClients = 0;
	nDataBytesSentToRemoteClients = 0;
	nDataItemsSentToRemoteClients = 0;

	// A typical source operator implementation will loop until shutdown.
	// In the code below, boost ASIO run method will block forever until
	// the server socket is closed. We will take measures for closing the
	// server socket in the prepareToShutdown method above when the operator is 
	// about to be shutdown. So, we need not go in a while loop as commonly
	// done in other source operators.
	// Hence, I commented out the following while loop line and its
	// corresponding close brace at the end of the code block below.
	//
	// while(!getPE().getShutdownRequested()) {

	iosRunLoopStarted = false;
	
	// If the user opted for an additional non-TLS (plain) 
	// Websocket endpoint, let us create that as well.
	// This non_tls insecure endpoint is here for a very 
	// remote possibility of this operator getting used with plain HTTP for any future use cases.
	// It is fine to provide both non_tls and TLS ports as it is
	// supported by the WebSocket++ library.
	if (nonTlsEndpointNeeded == true) {
		// Set up a non_tls endpoint without TLS.
		// Initialize asio with our external io_service rather than an internal one.
		endpoint_non_tls.init_asio(&ios);
		endpoint_non_tls.set_socket_init_handler(
			bind(&MY_OPERATOR::on_non_tls_socket_init, this, ::_1, ::_2));
		endpoint_non_tls.set_open_handler(
			bind(&MY_OPERATOR::on_open_non_tls, this, ::_1));
		endpoint_non_tls.set_message_handler(
			bind(&MY_OPERATOR::on_message<server_non_tls>, this,
			&endpoint_non_tls, ::_1, ::_2));
		endpoint_non_tls.set_close_handler(
			bind(&MY_OPERATOR::on_close, this, ::_1));
		// Set a connection validation handler inside which we can 
		// accept or reject a client's connection request.
		// This idea is discussed in these URLs:
		// https://www.zaphoyd.com/websocketpp/manual/common-patterns/conditionally-accepting-connections
		// https://docs.websocketpp.org/reference_8handlers.html
		// https://stackoverflow.com/questions/30558735/how-to-implement-a-websocket-server-serving-only-1-client-at-a-time
		endpoint_non_tls.set_validate_handler(
			bind(&MY_OPERATOR::validate_non_tls_client, this, ::_1));

		// Is this operator configured to receive HTTP POST messages from remote clients?
		if (allowHttpPost == true) {
			// This HTTP handler is only for HTTP posts (plain text, json, xml and blob).
			endpoint_non_tls.set_http_handler(bind(&MY_OPERATOR::on_http_message_non_tls, this, ::_1));
		}
		
		// https://docs.websocketpp.org/reference_8logging.html
		// Set the logging policy as needed
		// Turn off or turn on selectively all the Websocket++ access interface and 
		// error interface logging channels. Do this based on how the user has
		// configured this operator.
		if (websocketLoggingNeeded == true) {
			// Enable certain error logging channels and certain access logging channels.
			endpoint_non_tls.set_access_channels(
					websocketpp::log::alevel::frame_header);
			endpoint_non_tls.set_access_channels(
					websocketpp::log::alevel::frame_payload);
		} else {
			// Turn off both the access and error logging channels completely.
			endpoint_non_tls.clear_access_channels(websocketpp::log::alevel::all);
			endpoint_non_tls.clear_error_channels(websocketpp::log::elevel::all);
		}

		// Plain (non-TLS) endpoint listens on its own port.
		// Most of the modern day Linux machines will have an ipv6 protocol stack. 
		// By default, WebSocket++ listens in a dual stack ipv4/ipv6 mode. 
		// It will fail with the following error if an ipv6 stack is not available. 
		// "asio listen error: system:97 (Address family not supported by protocol)"
		// If it is an issue to enable ipv6 on a Linux macchine, a quick fix is to 
		// use one of the endpoint::listen overloads that lets us specify 
		// an address family to listen on and manually select to listen only via ipv4.
		// This solution is suggested in these URLs:
		// https://groups.google.com/forum/#!topic/websocketpp/-BB_Kr_rFPg
		// https://github.com/zaphoyd/websocketpp/issues/674
		if (ipv6Available == true) {
			endpoint_non_tls.listen(nonTlsPort);
		} else {
			// We must use only the ipv4 protocol stack in this case.
			endpoint_non_tls.listen(boost::asio::ip::tcp::v4(), nonTlsPort);
		}

		endpoint_non_tls.start_accept();
		nonTlsEndpointStarted = true;
	}

	// Set up a TLS endpoint at all times since some of the 
	// remote clients may use a secure endpoint.
	endpoint_tls.init_asio(&ios);
	endpoint_tls.set_socket_init_handler(
		bind(&MY_OPERATOR::on_tls_socket_init, this, ::_1, ::_2));
	endpoint_tls.set_open_handler(bind(&MY_OPERATOR::on_open_tls, this, ::_1));
	endpoint_tls.set_message_handler(
		bind(&MY_OPERATOR::on_message<server_tls>, this, &endpoint_tls,
		::_1, ::_2));
	endpoint_tls.set_close_handler(bind(&MY_OPERATOR::on_close, this, ::_1));
	// Set a connection validation handler inside which we can 
	// accept or reject a client's connection request.
	// This idea is discussed in these URLs:
	// https://github.com/zaphoyd/websocketpp/issues/422
	// https://www.zaphoyd.com/websocketpp/manual/common-patterns/conditionally-accepting-connections
	// https://docs.websocketpp.org/reference_8handlers.html
	// https://stackoverflow.com/questions/30558735/how-to-implement-a-websocket-server-serving-only-1-client-at-a-time
	endpoint_tls.set_validate_handler(
		bind(&MY_OPERATOR::validate_tls_client, this, ::_1));
	
	// TLS endpoint has an extra handler for the tls init
	endpoint_tls.set_tls_init_handler(
		bind(&MY_OPERATOR::on_tls_init, this, ::_1));
	
	// Is this operator configured to receive HTTPS POST messages from remote clients?
	if(allowHttpPost == true) {
		// This http handler is only for HTTPS posts (plain text, json, xml and blob).
		endpoint_tls.set_http_handler(bind(&MY_OPERATOR::on_http_message_tls, this, ::_1));
	}

	if (websocketLoggingNeeded == true) {
		// Enable certain error logging channels and certain access logging channels.
		endpoint_tls.set_access_channels(
			websocketpp::log::alevel::frame_header);
		endpoint_tls.set_access_channels(
			websocketpp::log::alevel::frame_payload);
	} else {
		// Turn off both the access and error logging channels completely.
		endpoint_tls.clear_access_channels(websocketpp::log::alevel::all);
		endpoint_tls.clear_error_channels(websocketpp::log::elevel::all);
	}

	// TLS endpoint listens on a different port.
	// Please refer to the detailed comments in the endpoint_non_tls.listen 
	// code block above about this ipv6 availability check.
	if (ipv6Available == true) {
		endpoint_tls.listen(tlsPort);
	} else {
		// We must use only the ipv4 protocol stack in this case.
		endpoint_tls.listen(boost::asio::ip::tcp::v4(), tlsPort);
	}

	// Start accepting the remote WebSocket client TLS connections now.
	endpoint_tls.start_accept();
	tlsEndpointStarted = true;

	// Start the Boost ASIO io_service run loop that can handle both endpoints.
	// This will block until the server socket gets closed.
	// For additional details, please refer to the commentary and 
	// logic in the prepareToShutdown method
	iosRunLoopStarted = true;
	ios.run();
	// }
} // End of process (for source operators)

// Tuple processing for mutating ports 
// This operator has two input ports.
// Port 0: Data to be sent (string or binary) arrives on this port.
// ---> Handled in the process method for mutating ports
//
// Port 1: New client whitelist arrives on this port.
// ---> Handled in the process method for mutating ports
//
// With the WebSocket interface, data is always sent to the 
// remote WebSocket clients over a persistent connection. 
//
// Since the Websocket interface keeps its request/response communication to 
// the remote WebSocket clients completely asynchronus on the full duplex TCP connection,
// our tuple processing here is going to be different from the way it is 
// usually done inside the Streams operators. 
// There will be multiple threads: One for receiving tuples on this 
// operator's input port, one for sending the data to the 
// remote Websocket clients and another for receiving data from the 
// remote WebSocket clients. It is somewhat different from the 
// usual stuff and very involved in terms of the logic. So, read the 
// code completely to understand what is going on inside all these threads.
//
// In the middle of the application run, a new client whitelist can be 
// injected into one of the input ports.
void MY_OPERATOR::process(Tuple & tuple, uint32_t port)
{
	// ========= START OF PROCESSING LOGIC FOR RESPONSE TUPLE =========
	<% if (defined($dataResponseToClientPortFound)) { %>
	// We need the logic here only if there is a data response to client input port defined.
	if(port == <%=$dataResponseToClientPortFound%>) {
		// There are multiple methods (process and ws_data_sender) that
		// regularly access (read, write and delete) the vector and map member variables.
		// All those methods work in parallel inside their own threads.
		// To make that vector access to be thread safe, we will 
		// use the mutex that is shown below.
		//
		// v1.1.1 change (Jan/29/2023)
		// Since there is no more sender thread starting in this release, 
		// this mutex is not used anymore in the sender method below.
		// However, we will use it at the entrypoint of this 
		// method here in order to have only one upstream
		// operator thread to do the data sending at any 
		// given time in case this operator is fused with 
		// a few other upstream operators where all of them 
		// try to push data tuples here from their operator threads.
		// If this operator runs on its own dedicated PE,
		// then there is no concern of multiple incoming 
		// upstream fused operator threads and this low overhead 
		// mutex is still beneficial.
		SPL::AutoMutex autoMutex1(wsMutex1);
		
		bool wsDataSenderMethodCalled = false;
		
		<% if(defined($httpResponseHeadersInputAsMapOfRStringAndRstring)) { %>
		// If there is a http response headers input attribute present,
		// we have to perform the following logic to store those headers for later use.
		//
		// If there is a non-empty httpResponseHeaders map found, we will 
		// store that map to be used later in the ws_data_sender thread.
		// We will do that only if this response is being sent to a HTTP client.
		//
		// Get the client id to which this data should be sent.
		ConstValueHandle handle2 = tuple.getAttributeValue("clientSessionId");
		uint64_t const & clientId = handle2;
		// Get the response headers.
		ConstValueHandle handle3 = tuple.getAttributeValue("httpResponseHeaders");
		SPL::map<SPL::rstring, SPL::rstring> const & myHeaders = handle3;
		
		if(SPL::Functions::Collections::size(myHeaders) > 0) {
			// We have a non-empty response header map.
			// We can store this map for later use only if the response is going to a HTTP client.
			// 
			// Note that we can't use a reference here without assigning it to a proper initial value.
			connection_metadata con_metadata;
			bool con_metadata_valid = false;
			
			try {
				// Mutex for the safe shared accessing of the client connections map.
				SPL::AutoMutex autoMutex3(wsMutex3);
				con_metadata_valid = false;
				// Get the metadata details for this client id from our client connections map.
				con_metadata = get_con_metadata_from_client_id(clientId);
				con_metadata_valid = true;
			} catch (const std::invalid_argument & e) {
				if (wsClientSessionLoggingNeeded == true) {
					SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
						"-->Channel " << boost::to_string(udpChannelNumber) << 
						"-->Client Session Id=" << clientId <<
						". Unable to get con_metadata-->" << e.what(), "process");
				}
			} catch (...) {
				if (wsClientSessionLoggingNeeded == true) {
					SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
						"-->Channel " << boost::to_string(udpChannelNumber) << 
						"-->Client Session Id=" << clientId <<
						". Unable to get con_metadata-->Other exception occurred.", "process");
				}
			}
			
			if(con_metadata_valid == true && con_metadata.isHttpConnection == true) {
				// This response is going to a remote client.
				// So, we can store the HTTP response header for later use.
				SPL::Functions::Collections::insertM(httpResponseHeaders, clientId, myHeaders);
			}
			
			if(con_metadata_valid == true && 
			   con_metadata.isHttpConnection == false &&
			   wsClientSessionLoggingNeeded == true) {
				SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
					"-->Channel " << boost::to_string(udpChannelNumber) << 
					"-->Client Session Id=" << clientId <<
					". Application logic is attempting to set HTTP response headers for " <<
					"a WebSocket client. It is not allowed and got ignored.", "process");
			}
		} // End of if(SPL::Functions::Collections::size(myHeaders) > 0)
		<%}%>
		
		// User of this operator can send data to the remote WebSocket clients as string or as blob.
		// Let us check what data is being sent by the user now.
		if (dataInputAsRString == true) {
			// Check if there is string based input data to be sent.
			ConstValueHandle handle0 = tuple.getAttributeValue("strData");
			rstring const & strData_rstring = handle0;
			std::string const & strData = strData_rstring.string();
			
			int32_t strDataLength = strData.length();
			
			if (strDataLength > 0) {
				// Push this data to the vector so that we can 
				// retrieve this data in the sender thread and send it to the remote WebSocket clients.
				strDataToSend.push_back(strData);
				// Get the client id to which this data should be sent.
				ConstValueHandle handle1 = tuple.getAttributeValue("clientSessionId");
				uint64_t const & clientId = handle1;
				// Push this client id to the vector to be retrieved in the sender thread.
				strDataToSendClientId.push_back(clientId);
				
				// v1.1.1 change (Jan/29/2023)
				// No more sender thread starting from this release. 
				// Instead, we are going to call the sender method whenever
				// there is a data item available to be sent to the connected clients.
				ws_data_sender();
				wsDataSenderMethodCalled = true;
			}
		}
		
		if (dataInputAsBlob == true) {
			// Check if there is blob based input data to be sent.
			ValueHandle handle0 = tuple.getAttributeValue("blobData");
			SPL::blob & blobData = handle0;
			uint64_t sizeOfBlobData = SPL::Functions::Collections::blobSize(blobData);
			
			if (sizeOfBlobData > 0) {
				// Release the blob data so that we can own the memory management of that data.
				// Get the blob's data pointer and store it in a vector for later use in the
				// Websocket data sender thread. In addition, store the size of
				// the blob as well in another vector which will be used later while sending the
				// blob data to the remote clients.
				//
				// Push this data to the vector so that we can 
				// retrieve this data in the sender thread and send it to the remote WebSocket clients.
				blobDataToSend.push_back(blobData.releaseData(sizeOfBlobData));
				// Push the size of the blob data as well for use in the sender thread.
				blobDataSize.push_back(sizeOfBlobData);
				// Get the client id to which this data should be sent.
				ConstValueHandle handle1 = tuple.getAttributeValue("clientSessionId");
				uint64_t const & clientId = handle1;
				// Push this client id to the vector to be retrieved in the sender thread.
				blobDataToSendClientId.push_back(clientId);

				// v1.1.1 change (Jan/29/2023)
				// No more sender thread starting from this release. 
				// Instead, we are going to call the sender method whenever
				// there is a data item available to be sent to the connected clients.
				ws_data_sender();
				wsDataSenderMethodCalled = true;
			}
		}
		
		// If we didn't call the ws_data_sender method due to empty payload (string and blob),
		// then we must clean up the response headers that we may have inserted into a map above.
		if(wsDataSenderMethodCalled == false) {
			ConstValueHandle handle1 = tuple.getAttributeValue("clientSessionId");
			uint64_t const & clientId = handle1;
			
			// Remove it only if it exists in the map.
			if(SPL::Functions::Collections::has(httpResponseHeaders, clientId) == true) {
				SPL::Functions::Collections::removeM(httpResponseHeaders, clientId);
			}
		}
	} // End of if(port == <%=$dataResponseToClientPortFound%>)
	<%}%>
	// ========= END OF PROCESSING LOGIC FOR RESPONSE TUPLE =========
	
	// ========= START OF PROCESSING LOGIC FOR CLIENT WHITELIST TUPLE =========
	<% if(defined($clientWhitelistUpdatePortFound)) { %>
	// We need the logic here only if there is an input port defined for
	// dynamically updating the client whitelist.
	if(port == <%=$clientWhitelistUpdatePortFound%>) {
		// There are multiple methods (process and validate_client) that
		// access (read, write) the client whitelist member variable.
		// All those methods work in parallel inside their own threads.
		// To make that list access to be thread safe, we will use this mutex.
		SPL::AutoMutex autoMutex2(wsMutex2);
		ConstValueHandle handle0 = tuple.getAttributeValue("clientWhitelist");
		SPL::list<rstring> currentClientWhitelist = clientWhitelist;
		// Assign it to our member variable.
		clientWhitelist = handle0;
		
		SPLAPPTRC(L_ERROR, 
			"Operator " <<
			operatorPhysicalName <<
			"-->Channel " << boost::to_string(udpChannelNumber) <<
			". Received a new client whitelist. Current whitelist= " <<
			currentClientWhitelist << ", New whitelist= " << 
			clientWhitelist << 
			". If the new whitelist is empty, any client can connect here. " <<
			"Otherwise, only the clients specified in the whitelist can connect here. " << 
			"In that case, currently connected clients that are not specified in " <<
			"the new whitelist will be terminated now.", "process");
		
		// Terminate existing clients that are not specified in the new whitelist.
		SPL::int32 whitelistCnt = SPL::Functions::Collections::size(clientWhitelist);
		
		if(whitelistCnt <= 0) {
			// There is nothing in the client whitelist.
			// So, all clients can connect here without any restrictions.
			return;
		}
		
		// Mutex for the safe shared accessing of the client connections map.
		SPL::AutoMutex autoMutex3(wsMutex3);
		int32_t terminatedClientsCnt = 0;
		
		// There is a new client whitelist available. We can check if our existing clients 
		// that have already established a connection with this operator can continue to 
		// keep their connection or should they be terminated if not present in the new whitelist.
		// IP addresses in that whitelist can be exact or wildcard based as shown below.
		// clientWhitelist: ['172.34.18.212', '10.5.23.17', '172.*.42.*', '10.29.42.*'];
		//
		// We can start to loop through the client connections map and see
		// which clients are not allowed to connect with this operator anymore.
		for (con_map::iterator it = client_connections_map.begin();
			it != client_connections_map.end(); it++) {
			// Get the connection handle for the current client.
			websocketpp::connection_hdl con_hdl = it->first;
			// Get the connection meta data for the current client.
			connection_metadata & cmd = it->second;
			// Get the IP address for the current client.
			SPL::uint64 clientSessionId = cmd.clientSessionId;
			SPL::rstring remoteEndpoint = cmd.remoteEndpoint;
			SPL::rstring clientIp = cmd.clientIpAddress;
			SPL::rstring clientPort = cmd.clientPort;
			SPL::boolean isTlsConnection = cmd.isTlsConnection;
			SPL::boolean isHttpConnection = cmd.isHttpConnection;
			SPL::boolean clientAppearsInWhitelist = false;
			
			// Parse the remote client's IP address into four individual parts.
			// Since this client's IP address was already validated when it originally
			// connected here, it will have 4 parts for sure.
			SPL::list<SPL::rstring> clientIpParts = 
				SPL::Functions::String::tokenize(clientIp, ".", true);
	
			// We can now loop through the new client whitelist and see 
			// if a given clientIp is specified in it.
			for(SPL::int32 cnt = 0; cnt < whitelistCnt; cnt++) {
				// Get the next available whitelist entry.
				SPL::rstring allowedIp = clientWhitelist[cnt];
				// Parse this entry's Ip address into four individual parts.
				SPL::list<SPL::rstring> allowedIpParts = 
					SPL::Functions::String::tokenize(allowedIp, ".", true);
				
				if(SPL::Functions::Collections::size(allowedIpParts) != 4) {
					// Not enough parts available for this entry to be useful to us.
					// Skip this one and continue with the inner for loop.
					continue;
				}
	
				// Let us now validate to see if the remote client IP is allowed to 
				// keep going via its existing connection with this operator.
				// Check to see if part 1, part 2, part 3 and part 4 have either
				// wildcard or a match.
				if ((allowedIpParts[0] == "*" || clientIpParts[0] == allowedIpParts[0]) &&
					(allowedIpParts[1] == "*" || clientIpParts[1] == allowedIpParts[1]) &&
					(allowedIpParts[2] == "*" || clientIpParts[2] == allowedIpParts[2]) &&
					(allowedIpParts[3] == "*" || clientIpParts[3] == allowedIpParts[3])) {
					// This remote client has a match in the whitelist. 
					// Let us allow it to keep its connection here.
					// Break from the inner for loop.
					clientAppearsInWhitelist = true;
					break;
				}
			} // End of the for loop iterating over the client whitelist.
			
			if(clientAppearsInWhitelist == true) {
				// The current client is good to keep its connection.
				// Continue the outer for loop to check the next active client.
				continue;
			}
			
			// This remote client is no longer specified in the whitelist.
			// Properly close this client's connection now.
			std::string closeReason =
				"This client is no longer in the whitelist. So streamsx.websocket is closing this connection";
			websocketpp::lib::error_code ec;
	
			// This connection closing technique is discussed in these URLs:
			// https://stackoverflow.com/questions/25260852/shut-down-websocket-connection
			// https://github.com/zaphoyd/websocketpp/issues/803
			// https://mayaposch.wordpress.com/2015/09/16/creating-a-websocket-server-with-websocket/
			//
			// IMPORTANT
			// ---------
			// Even though it is a forceful client connection termination done from the server side, 
			// there will still be triggers into the on_close callback method that appears below 
			// in this class. So, all the connection meta data cleanup will be taken care of 
			// inside that method. We will only focus here on closing the client connection.
			if(isTlsConnection == false) {
				endpoint_non_tls.close(con_hdl, websocketpp::close::status::normal,
					closeReason, ec);
			} else {
				endpoint_tls.close(con_hdl, websocketpp::close::status::normal,
					closeReason, ec);
			}
	
			terminatedClientsCnt++;
			
			if (wsConnectionLoggingNeeded == true) {
				SPLAPPTRC(L_ERROR, 
					"Operator " <<
					operatorPhysicalName <<
					"-->Channel " << boost::to_string(udpChannelNumber) <<
					". This remote client is no longer in the whitelist. So, its connection is being closed. " <<
					"nClientsConnected=" << nClientsConnected-terminatedClientsCnt << 
					", maxClientConnectionsAllowed=" << maxClientConnectionsAllowed <<
					", clientSessionId=" << clientSessionId <<
					", hdl=" << con_hdl.lock().get() <<
					", remoteEndpoint=" << remoteEndpoint <<
					", clientIp=" << clientIp <<
					", clientPort=" << clientPort <<
					", isTlsConnection=" << isTlsConnection <<
					", isHttpConnection=" << isHttpConnection, "process");	
			}
		} // End of the for loop iterating over the client connections map.
	
		if (wsConnectionLoggingNeeded == true && terminatedClientsCnt > 0) {
			SPLAPPTRC(L_ERROR, 
				"Operator " <<
				operatorPhysicalName <<
				"-->Channel " << boost::to_string(udpChannelNumber) <<
				". A total of " << terminatedClientsCnt << " remote clients were disconnected " <<
				"since they are no longer specified in the whitelist. " <<
				"nClientsConnected=" << nClientsConnected-terminatedClientsCnt << 
				", maxClientConnectionsAllowed=" << maxClientConnectionsAllowed, "process");	
		}
	} // End of if(port == <%=$clientWhitelistAsListOfRString%>)
	<%}%>
	// ========= END OF PROCESSING LOGIC FOR CLIENT WHITELIST TUPLE =========
} // End of process (mutating ports)

// Tuple processing for non-mutating ports
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port) {
} // End of process (non-mutating ports)

// Punctuation processing
void MY_OPERATOR::process(
	Punctuation const & punct,
	uint32_t port) {
	// This is primarily a source operator.
	// Even though it has an input port to receive tuples that are to be
	// sent to the remote clients, we don't have to deal with the
	// punctuations coming on that input port. Let us keep quiet here.

	/*
	 if(punct==Punctuation::WindowMarker) {
	 // ...;
	 } else if(punct==Punctuation::FinalMarker) {
	 // ...;
	 }
	 */
}

// We need the following data sender thread only if there is a 
// data response to client input port.
<% if (defined($dataResponseToClientPortFound)) { %>
// This method provides a thread for the Websocket data sender.
//
// v1.1.1 change (Jan/29/2023)
// There is no more sender thread starting in this release.
// You can see that the thread creation for this method in the
// allPortsReady method above is fully commented out.
// This is now just a callable method with no need for mutex
// coordination with the input tuple process method above.
// Whenever there is a data item available to sent to the 
// connected clients, process method will call this method after
// appending the blob and/or string into the appropriate list.
// This method will send the available data item and then
// remove it from the list.
//
// I did this "from being a thread to being a non-thread callable method"
// change because the earlier approach did it by making the process method  
// to keep receiving the data items and pushing them into a vector and
// the sender thread to dequeue from that vector and send it away.
// In the earlier approach of keeping a shared vector between the
// process and sender threads controlled via a mutex let the 
// process method to accumulate millions of tuples in its vector
// in a few minutes and then the sender thread taking too much
// CPU time (in high tens of milliseconds) to dequeue, send and
// remove the data item from such a bloated vector. In particular,
// removing element 0 of a vector with hundreds of thousands of
// elements in it was horribly punishing in the time it took to do it.
// It made the sending logic to become very sluggish to cause severe
// performance slowdown by not being able to send the data items
// to the remote clients in a fast manner. Hence, I changed the
// sender logic below from a long running thread loop to a 
// stateless callable method. In this scheme, there will only be
// one data item in a vector to be sent at any given time and not
// millions of entries in a vector to access and then remove.
// My tests in our lab showed far better results.
//
void MY_OPERATOR::ws_data_sender() {
	SPL::int64 timeTakenToSendDataItem = 0;
	
	// v1.1.1 change (Jan/29/2023)
	// Since it is no longer a long running thread loop,
	// there is no need for this while loop.
	// while (!getPE().getShutdownRequested()) {
		// Keep waiting in this while loop until
		// there is data that needs to be sent to the remote WebSocket clients.
		SPL::timestamp tsBeforeSendingDataItem = SPL::Functions::Time::getTimestamp();
		
		// Wait for a configured amount of time that is not 0.0 when there is
		// data actively available for sending.
		// When there is no data available to send, yield the CPU for
		// slightly a longer time.
		int32_t blobDataVectorSize = blobDataToSend.size();
		int32_t blobDataClientIdVectorSize = blobDataToSendClientId.size();
		int32_t strDataVectorSize = strDataToSend.size();
		int32_t strDataClientIdVectorSize = strDataToSendClientId.size();
		
		// V1.1.1 change (Jan/29/2023)
		// Since there is no more long running thread while loop 
		// starting in this release, there is no need for CPU yielding.
		/*
		if(blobDataVectorSize <= 0 && strDataVectorSize <= 0) {
			// There is no data available to be sent at this time.
			// Yield the CPU for a little time.
			// 1 milli second by default which can be parameterized at the
			// time of operator invocation inside the application.
			SPL::Functions::Utility::block(noDataCpuYieldTimeInSenderThread);
		} else if (newDataCpuYieldTimeInSenderThread > 0.0) {
			// New data is available now for sending. Yield the CPU briefly and get to work soon.
			// Even a tiny value of 1 millisecond (0.001 second) will yield the
			// CPU and will not show 0% idle in the Linux top command.
			// This wait time can be configured via an operator parameter.
			SPL::Functions::Utility::block(newDataCpuYieldTimeInSenderThread);
		}
		*/
		
		// Check if there is data waiting to be sent to the remote WebSocket clients.
		if (blobDataVectorSize > 0 || strDataVectorSize > 0) {
			// V1.1.1 change (Jan/29/2023)
			// Since there is more sender thread starting in this release,
			// we have no need for a mutex to coordinate with the
			// input tuple process method. This sender method will simply be
			// called from that other method whenever there is 
			// data available to be sent.
			//
			/*
			// There are multiple methods (process and ws_data_sender) that
			// regularly access (read, write and delete) the vector and map member variables.
			// All those methods work in parallel inside their own threads.
			// To make that vector access thread safe, we will use this mutex.
			SPL::AutoMutex autoMutex1(wsMutex1);
			*/
			
			uint64_t payloadSize = 0;
			uint64_t clientId = 0;

			// We can send out the next data item only if there are any
			// remote WebSocket clients that are connected to this operator at this time.
			if(nClientsConnected <= 0) {
				// There is no place to send the data item.
				// So, simply do a cleanup of the vector(s) and 
				// continue back to the top of this sender thread.
				if (blobDataVectorSize > 0) {
					// We have a blob data item available which can't be sent now.
					unsigned char * buffer = blobDataToSend.at(0);	
					
					// Remove the items from the vector. It is no longer needed. Also free the original 
					// data pointer that we obtained from the blob in the process method.
					if (buffer != NULL) {
						delete buffer;
					}
					
					clientId = blobDataToSendClientId.at(0);
					blobDataToSend.erase(blobDataToSend.begin() + 0);
					blobDataSize.erase(blobDataSize.begin() + 0);
					blobDataToSendClientId.erase(blobDataToSendClientId.begin() + 0);
					blobDataVectorSize--;
				}  else if (strDataVectorSize > 0) {
					// We have a string data item available which can't be sent now.
					// Erase the item pushed into the vector member (cache) earlier in the 
					// process method for this data item. It is no longer needed.
					clientId = strDataToSendClientId.at(0);
					strDataToSend.erase(strDataToSend.begin() + 0);
					strDataToSendClientId.erase(strDataToSendClientId.begin() + 0);
					strDataVectorSize--;
				}
				
				// If this data item to be sent was targeted to a remote HTTP client,
				// there may be an associated HTTP response header entry as well.
				// If so, let us remove that entry from its map.
				if(SPL::Functions::Collections::has(httpResponseHeaders, clientId) == true) {
					SPL::Functions::Collections::removeM(httpResponseHeaders, clientId);
				}
				
				// V1.1.1 change (Jan/29/2023)
				// Since there is no more long running thread while loop
				// starting in this release, we don't need the following
				// while loop continue statement. Instead we will simply 
				// return to the caller of this method.
				//
				// continue;
				//
				return;
			} // End of if(nClientsConnected <= 0)

			// Mutex for the safe shared accessing of the client connections map.
			SPL::AutoMutex autoMutex3(wsMutex3);
			bool con_metadata_valid = false;
			connection_metadata con_metadata;
			websocketpp::lib::error_code ec;
			
			// We have clients connected at this time, Send the data item to them. 
			if (blobDataVectorSize > 0) {
				// We have a blob data item available to send.
				unsigned char * buffer = blobDataToSend.at(0);
				payloadSize = blobDataSize.at(0);
				// Send it to the client id associated with this message.
				clientId = blobDataToSendClientId.at(0);
				
				try {
					con_metadata_valid = false;
					// Get the metadata details for this client id from our client connections map.
					con_metadata = get_con_metadata_from_client_id(clientId);
					con_metadata_valid = true;
				} catch (const std::invalid_argument & e) {
					if (wsClientSessionLoggingNeeded == true) {
						SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
							"-->Channel " << boost::to_string(udpChannelNumber) << 
							"-->Client Session Id=" << clientId <<
							". (binary data) Unable to get con_metadata-->" << e.what(), "ws_data_sender");
					}
				} catch (...) {
					if (wsClientSessionLoggingNeeded == true) {
						SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
							"-->Channel " << boost::to_string(udpChannelNumber) << 
							"-->Client Session Id=" << clientId <<
							". (binary data) Unable to get con_metadata-->Other exception occurred.", "ws_data_sender");
					}
				}					
				
				if (buffer !=  NULL && payloadSize > 0 && con_metadata_valid == true) {					
					if(con_metadata.isHttpConnection == false && 
					   con_metadata.isTlsConnection == false) {
						try {
							endpoint_non_tls.send(con_metadata.hdl, buffer,
								payloadSize, websocketpp::frame::opcode::binary);
						} catch (websocketpp::exception const & e) {
							// Do nothing here.
						}
					} else if(con_metadata.isHttpConnection == false && 
					   con_metadata.isTlsConnection == true) {
						try {
							endpoint_tls.send(con_metadata.hdl, buffer, 
								payloadSize, websocketpp::frame::opcode::binary);
						} catch (websocketpp::exception const & e) {
							// Do nothing here.
						}
					} else if(con_metadata.isHttpConnection == true && 
					  con_metadata.isTlsConnection == false) {
						// Send a deferred response back to the non_tls HTTP based client.
						// Please read the commentary in the create_new_connection_entry method below
						// to learn why we stored the HTTP connection pointer in con_metadata.
						server_non_tls::connection_ptr con_non_tls = con_metadata.http_con_non_tls;

						if (con_non_tls != NULL) {
							try {
								bool contentTypeHeaderAlreadyPresent = false;
								// Let us see if we have the application provided
								// custom HTTP response headers for this remote HTTP client.
								if(SPL::Functions::Collections::has(httpResponseHeaders, clientId) == true) {
									// Get the headers map.
									SPL::map<SPL::rstring, SPL::rstring> myHeaders = 
										httpResponseHeaders[clientId];
									// Get the keys for this map.
									SPL::list<SPL::rstring> myKeys = 
										SPL::Functions::Collections::keys(myHeaders);
									SPL::int32 numberOfKeys = 
										SPL::Functions::Collections::size(myKeys);
									
									for(int32_t cnt = 0; cnt < numberOfKeys; cnt++) {
										try {
											con_non_tls->replace_header(myKeys[cnt], myHeaders[myKeys[cnt]]);
											
											if(myKeys[cnt] == "Content-Type") {
												contentTypeHeaderAlreadyPresent = true;
											}
										} catch(...) {
											if (wsClientSessionLoggingNeeded == true) {
												SPLAPPTRC(L_ERROR,
													"Operator "
													<< operatorPhysicalName
													<< "-->Channel " << boost::to_string(udpChannelNumber)
													<< "-->clientId=" << clientId
													<< "-->Binary non_tls-->Invalid HTTP response header-->" 
													<< myKeys[cnt] << ":" 
													<< myHeaders[myKeys[cnt]], "ws_data_sender");									
											}
										}
									}									
								}
								
								// Since it is a binary response, we must set the
								// content type header to application/octet-stream.
								// Replace it only if user has not set his/her own value for this header.
								if(contentTypeHeaderAlreadyPresent == false) {
									con_non_tls->replace_header(std::string("Content-Type"),
										std::string("application/octet-stream"));
								}
								
								// It is a good practice to send a Connection: close header in the 
								// response when we are not keeping a persistent (Keep-Alive) connection. 
								con_non_tls->replace_header(std::string("Connection"),
									std::string("close"));
								con_non_tls->set_body(std::string((const char*)buffer, payloadSize));
								con_non_tls->set_status(websocketpp::http::status_code::ok);
								// This is a deferred response to a remote HTTP client.
								con_non_tls->send_http_response(ec);	
							} catch (websocketpp::exception const & e) {
								// Do nothing here.
							}
						}
					} else if(con_metadata.isHttpConnection == true && 
					  con_metadata.isTlsConnection == true) {
						// Send a deferred response back to the TLS HTTP based client.
						// Please read the commentary in the create_new_connection_entry method below
						// to learn why we stored the HTTP connection pointer in con_metadata.
						server_tls::connection_ptr con_tls = con_metadata.http_con_tls;
						
						if (con_tls != NULL) {
							try {
								bool contentTypeHeaderAlreadyPresent = false;
								// Let us see if we have the application provided
								// custom HTTP response headers for this remote HTTP client.
								if(SPL::Functions::Collections::has(httpResponseHeaders, clientId) == true) {
									// Get the headers map.
									SPL::map<SPL::rstring, SPL::rstring> myHeaders = 
										httpResponseHeaders[clientId];
									// Get the keys for this map.
									SPL::list<SPL::rstring> myKeys = 
										SPL::Functions::Collections::keys(myHeaders);
									SPL::int32 numberOfKeys = 
										SPL::Functions::Collections::size(myKeys);
									
									for(int32_t cnt =  0; cnt < numberOfKeys; cnt++) {
										try {
											con_tls->replace_header(myKeys[cnt], myHeaders[myKeys[cnt]]);
											
											if(myKeys[cnt] == "Content-Type") {
												contentTypeHeaderAlreadyPresent = true;
											}
										} catch(...) {
											if (wsClientSessionLoggingNeeded == true) {
												SPLAPPTRC(L_ERROR,
													"Operator "
													<< operatorPhysicalName
													<< "-->Channel " << boost::to_string(udpChannelNumber)
													<< "-->clientId=" << clientId
													<< "-->Binary tls-->Invalid HTTP response header-->" 
													<< myKeys[cnt] << ":" 
													<< myHeaders[myKeys[cnt]], "ws_data_sender");									
											}
										}
									}
								}

								// Since it is a binary response, we must set the
								// content type header to application/octet-stream.
								// Replace it only if user has not set his/her own value for this header.
								if(contentTypeHeaderAlreadyPresent == false) {
									con_tls->replace_header(std::string("Content-Type"),
										std::string("application/octet-stream"));
								}
								
								// It is a good practice to send a Connection: close header in the 
								// response when we are not keeping a persistent (Keep-Alive) connection. 
								con_tls->replace_header(std::string("Connection"),
									std::string("close"));
								con_tls->set_body(std::string((const char*)buffer, payloadSize));
								con_tls->set_status(websocketpp::http::status_code::ok);
								// This is a deferred response to a remote HTTP client.
								con_tls->send_http_response(ec);	
							} catch (websocketpp::exception const & e) {
								// Do nothing here.
							}
						}
					}
				} // End of if (buffer !=  NULL && payloadSize > 0 && con_metadata_valid == true)

				// Remove the items from the vector. It is no longer needed. Also free the original 
				// data pointer that we obtained from the blob in the process method.
				if (buffer != NULL) {
					delete buffer;
				}
				
				blobDataToSend.erase(blobDataToSend.begin() + 0);
				blobDataSize.erase(blobDataSize.begin() + 0);
				blobDataToSendClientId.erase(blobDataToSendClientId.begin() + 0);
				blobDataVectorSize--;
			} else if (strDataVectorSize > 0) {
				// We have a string data item available to send.
				payloadSize = strDataToSend.at(0).length();	
				// Send it to the client id associated with this message.
				clientId = strDataToSendClientId.at(0);
				
				try {
					con_metadata_valid = false;
					// Get the metadata details for this client id from our client connections map.
					con_metadata = get_con_metadata_from_client_id(clientId);
					con_metadata_valid = true;
				} catch (const std::invalid_argument & e) {
					if (wsClientSessionLoggingNeeded == true) {
						SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
							"-->Channel " << boost::to_string(udpChannelNumber) << 
							"-->Client Session Id=" << clientId <<
							". (text data) Unable to get con_metadata-->" << e.what(), "ws_data_sender");
					}
				} catch (...) {
					if (wsClientSessionLoggingNeeded == true) {
						SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
							"-->Channel " << boost::to_string(udpChannelNumber) << 
							"-->Client Session Id=" << clientId <<
							". (text data) Unable to get con_metadata-->Other exception occurred.", "ws_data_sender");
					}
				}
				
				if (payloadSize > 0 && con_metadata_valid == true) {
					if(con_metadata.isHttpConnection == false && 
					   con_metadata.isTlsConnection == false) {
						try {
							// This is a non_tls WebSocket based client.
							endpoint_non_tls.send(con_metadata.hdl, strDataToSend.at(0), 
								websocketpp::frame::opcode::text);
						} catch (websocketpp::exception const & e) {
							// Do nothing here.
						}
					} else if(con_metadata.isHttpConnection == false && 
					  con_metadata.isTlsConnection == true) {
						try {
							// This is a TLS WebSocket based client.
							endpoint_tls.send(con_metadata.hdl, strDataToSend.at(0),
								websocketpp::frame::opcode::text);
						} catch (websocketpp::exception const & e) {
							// Do nothing here.
						}
					} else if(con_metadata.isHttpConnection == true && 
					  con_metadata.isTlsConnection == false) {
						// Send a deferred response back to the non_tls HTTP based client.
						// Please read the commentary in the create_new_connection_entry method below
						// to learn why we stored the HTTP connection pointer in con_metadata.
						server_non_tls::connection_ptr con_non_tls = con_metadata.http_con_non_tls;

						if (con_non_tls != NULL) {
							try {
								// Let us see if we have the application provided
								// custom HTTP response headers for this remote HTTP client.
								if(SPL::Functions::Collections::has(httpResponseHeaders, clientId) == true) {
									// Get the headers map.
									SPL::map<SPL::rstring, SPL::rstring> myHeaders = 
										httpResponseHeaders[clientId];
									// Get the keys for this map.
									SPL::list<SPL::rstring> myKeys = 
										SPL::Functions::Collections::keys(myHeaders);
									SPL::int32 numberOfKeys = 
										SPL::Functions::Collections::size(myKeys);
									
									for(int32_t cnt = 0; cnt < numberOfKeys; cnt++) {
										try {
											con_non_tls->append_header(myKeys[cnt], myHeaders[myKeys[cnt]]);
										} catch(...) {
											if (wsClientSessionLoggingNeeded == true) {
												SPLAPPTRC(L_ERROR,
													"Operator "
													<< operatorPhysicalName
													<< "-->Channel " << boost::to_string(udpChannelNumber)
													<< "-->clientId=" << clientId
													<< "-->Text non_tls-->Invalid HTTP response header-->" 
													<< myKeys[cnt] << ":" 
													<< myHeaders[myKeys[cnt]], "ws_data_sender");									
											}
										}
									}									
								}
								
								// It is a good practice to send a Connection: close header in the 
								// response when we are not keeping a persistent (Keep-Alive) connection. 
								con_non_tls->replace_header(std::string("Connection"),
									std::string("close"));
								con_non_tls->set_body(strDataToSend.at(0));
								con_non_tls->set_status(websocketpp::http::status_code::ok);
								// This is a deferred response to a remote HTTP client.
								con_non_tls->send_http_response(ec);	
							} catch (websocketpp::exception const & e) {
								// Do nothing here.
							}
						}
					} else if(con_metadata.isHttpConnection == true && 
					  con_metadata.isTlsConnection == true) {
						// Send a deferred response back to the TLS HTTP based client.
						// Please read the commentary in the create_new_connection_entry method below
						// to learn why we stored the HTTP connection pointer in con_metadata.
						server_tls::connection_ptr con_tls = con_metadata.http_con_tls;
						
						if (con_tls != NULL) {
							try {
								// Let us see if we have the application provided
								// custom HTTP response headers for this remote HTTP client.
								if(SPL::Functions::Collections::has(httpResponseHeaders, clientId) == true) {
									// Get the headers map.
									SPL::map<SPL::rstring, SPL::rstring> myHeaders = 
										httpResponseHeaders[clientId];
									// Get the keys for this map.
									SPL::list<SPL::rstring> myKeys = 
										SPL::Functions::Collections::keys(myHeaders);
									SPL::int32 numberOfKeys = 
										SPL::Functions::Collections::size(myKeys);
									
									for(int32_t cnt =  0; cnt < numberOfKeys; cnt++) {
										try {
											con_tls->append_header(myKeys[cnt], myHeaders[myKeys[cnt]]);
										} catch(...) {
											if (wsClientSessionLoggingNeeded == true) {
												SPLAPPTRC(L_ERROR,
													"Operator "
													<< operatorPhysicalName
													<< "-->Channel " << boost::to_string(udpChannelNumber)
													<< "-->clientId=" << clientId
													<< "-->Text tls-->Invalid HTTP response header-->" 
													<< myKeys[cnt] << ":" 
													<< myHeaders[myKeys[cnt]], "ws_data_sender");									
											}
										}
									}
								}

								// It is a good practice to send a Connection: close header in the 
								// response when we are not keeping a persistent (Keep-Alive) connection. 
								con_tls->replace_header(std::string("Connection"),
									std::string("close"));
								con_tls->set_body(strDataToSend.at(0));
								con_tls->set_status(websocketpp::http::status_code::ok);
								// This is a deferred response to a remote HTTP client.
								con_tls->send_http_response(ec);	
							} catch (websocketpp::exception const & e) {
								// Do nothing here.
							}
						}
					}
				} // End of if (payloadSize > 0 && con_metadata_valid == true)
				
				// Erase the item pushed into the vector member (cache) earlier in the 
				// process method for this data item. It is no longer needed.
				strDataToSend.erase(strDataToSend.begin() + 0);
				strDataToSendClientId.erase(strDataToSendClientId.begin() + 0);
				strDataVectorSize--;
			} // if (blobDataVectorSize > 0)			

			// If this data item to be sent was targeted for a remote HTTP client,
			// there may be an associated HTTP response header entry as well.
			// If so, let us remove that entry from its map.
			if(SPL::Functions::Collections::has(httpResponseHeaders, clientId) == true) {
				SPL::Functions::Collections::removeM(httpResponseHeaders, clientId);
			}			
			
			// Update the metrics counters now.
			if(payloadSize > 0 && con_metadata_valid == true) {
				// Upate the client specific counters.
				con_metadata.dataItemsSentCnt++;
				con_metadata.dataBytesSent += payloadSize;
				// Update the global counters.
				nDataItemsSentToRemoteClients++;
				nDataBytesSentToRemoteClients += payloadSize;
			}

			if(con_metadata_valid == true) {
				// A response got sent just now to a remote client.
				// Let us reset the response timeout counter to indicate that
				// there is no response due at this time.
				con_metadata.responseTimeoutCounter = -1;
				// Store the updated con_metadata into our associative container.
				client_connections_map[con_metadata.hdl] = con_metadata;
			}
			
			// Calculate the time it took to send the data item.
			SPL:timestamp tsAfterSendingDataItem = SPL::Functions::Time::getTimestamp();
			timeTakenToSendDataItem = 
				SPL::Functions::Time::diffAsNanos(tsAfterSendingDataItem, tsBeforeSendingDataItem);
			// Convert nanoseconds to milliseconds.
			timeTakenToSendDataItem /= 1000000;
			
			// Update the operator metric only if the user asked for a live update.
			if (websocketLiveMetricsUpdateNeeded == true && 
				con_metadata_valid == true && payloadSize > 0) {
				nDataItemsSentToRemoteClientsMetric->setValueNoLock(nDataItemsSentToRemoteClients);
				nDataBytesSentToRemoteClientsMetric->setValueNoLock(nDataBytesSentToRemoteClients);
				nTimeTakenToSendMostRecentDataItemMetric->setValueNoLock((SPL::uint64)timeTakenToSendDataItem);
				nSizeOfMostRecentDataItemSentMetric->setValueNoLock(payloadSize);
			}
									
			if (wsClientSessionLoggingNeeded == true && 
				con_metadata_valid == true && payloadSize > 0) {
				SPLAPPTRC(L_ERROR,
					"Operator "
					<< operatorPhysicalName
					<< "-->Channel " << boost::to_string(udpChannelNumber)
					<< "-->X10 Sent data to a remote WebSocket client. "
					<< "clientSessionId=" << con_metadata.clientSessionId
					<< ", hdl=" << con_metadata.hdl.lock().get()
					<< ", remoteEndpoint=" << con_metadata.remoteEndpoint
					<< ", clientIp=" << con_metadata.clientIpAddress
					<< ", clientPort=" << con_metadata.clientPort
					<< ", isTlsConnection=" << con_metadata.isTlsConnection
					<< ", isHttpConnection=" << con_metadata.isHttpConnection
					<< ", serverIp=" << con_metadata.serverIpAddress
					<< ", serverPort=" << con_metadata.serverPort
					<< ", responseTimeoutCounter=" << con_metadata.responseTimeoutCounter
					<< ", dataItemsSentCnt=" << con_metadata.dataItemsSentCnt
					<< ", dataBytesSent=" << con_metadata.dataBytesSent	
					<< ", timeTakenToSendMostRecentDataItemInMillis=" << timeTakenToSendDataItem
					<< ", sizeOfMostRecentDataItemSent=" << payloadSize
					<< ", nClientsConnected=" << nClientsConnected
					<< ", total data items sent to all clients=" << nDataItemsSentToRemoteClients
					<< ", total data bytes sent to all clients=" << nDataBytesSentToRemoteClients
					<< ", size of blobDataToSend vector=" << blobDataVectorSize
					<< ", size of strDataToSend vector=" << strDataVectorSize
					<< ", size of blobDataToSendClientId vector=" << blobDataClientIdVectorSize
					<< ", size of strDataToSendClientId vector=" << blobDataClientIdVectorSize,
					"ws_data_sender");				
			}
			
			if(con_metadata_valid == true) {
				if(con_metadata.isHttpConnection == true) {
					// If we just now finished dealing with a HTTP based remote client, 
					// then we must do an in-memory clean-up for that client connection.
					// HTTP POST client connections are made fresh for every message exchange.
					// So, we are done with this particular HTTP client connection.
					// Delete this client session id from the map we maintain to do a
					// faster search of a connection handle by using a client session id.
					client_id_to_hdl_map.erase(con_metadata.clientSessionId);
		
					// Delete this handle from our associative container.        
					client_connections_map.erase(con_metadata.hdl);
					
					// We are now with one less client connection.
					nClientsConnected -= 1;
					
					// Update the operator metric only if the user asked for a live update.
					if (websocketLiveMetricsUpdateNeeded == true) {
						nClientsConnectedMetric->setValueNoLock(nClientsConnected);
					}
					
					// Please note that unlike in the on_close for WebSocket connections, we are not
					// going to send an "End of Client Session" signal on output port 1.
					// Because, it will simply be too many of them for the 
					// HTTP based request/response connections.
				}
			} else {
				// If the application layer sends an invlaid client id, then we will reach here.
				// Other than for that reason, there is a very rare chance that 
				// we will ever reach here inside this else block.
				SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
					"-->Channel " << boost::to_string(udpChannelNumber) << 
					"-->Client Session Id=" << clientId <<
					"-->Unable to get con_metadata for that client session id. " <<
					"So, it is hard to determine if it involved an in-memory clean-up of "
					"a HTTP based client connection that we couldn't perform. " <<
					"If this situation occurs frequently, please be aware of the fact " <<
					"that it can lead to an out of memory condition." , "ws_data_sender");
			} // End of if(con_metadata_valid == true)
			
			// Continue from the top of the outer while loop.
			// V1.1.1 change (Jan/29/2023)
			// Since there is no more long running thread while loop
			// starting in this release, we don't need the following
			// while loop continue statement. Instead we will simply 
			// return to the caller of this method.
			//
			// continue;
		} // End of if ((blobDataVectorSize > 0 ||
	// V1.1.1 change (Jan/29/2023)
	// There is no more long running thread while loop starting in this release.
	// } // End of the outer while loop	
} // End of ws_data_sender

// This method provides a thread for handling the 
// Websocket/HTTP response timeout occurrences.
// Practically speaking, there is no such thing called
// timeout for WebSocket connections as they are persistent and
// full duplex (bidirectional). That connection allows both
// parties to exchange data at anytime they want.
// However, HTTP connections have timeout and typically one request per
// message. So. the logic in this method is mostly to address
// the application response timeout concerns for HTTP even though
// it does the same thing for WebSocket clients. So, the application logic
// and the WebSocket client can also do their own additional 
// timeout handling outside the scope of what this method does.
// So, it is important to note that the logic below will be able to
// detect response timeout conditions for every single HTTP message
// received from a client. That is easy since every HTTP message from a
// client arrives on a separate HTTP connection which results in a unique
// connection handle. We can't do the same for the messages received from a 
// client via a pure WebSocket connection since there will be only one
// long running persistent full duplex connection over which messages can be
// sent both ways at any time. The logic below will notify response timeout
// only at the end of a burst of messages received from a WebSocket client
// that all happen to miss the responses from the application logic. As explained
// above, that practice is fine for a WebSocket based connection since there are other 
// ways in which response timeout can be detected and handled in the applications
// running on both ends. But, for the HTTP POST client connections, it is necessary
// to handle response timeout conditions on connection by connection basis.
void MY_OPERATOR::ws_response_timeout_handler() {
	websocketpp::lib::error_code ec;
	std::list<websocketpp::connection_hdl> response_timed_out_handles;
	std::string msg = 
		std::string("Application logic timed out without sending a required response. ") +
		std::string("You may retransmit your data item.");
	int32_t sleepTimeInSeconds = 2;
	
	while (!getPE().getShutdownRequested()) {
		// Wake up every two seconds.
		SPL::Functions::Utility::block((SPL::float64)sleepTimeInSeconds);
		
		// Loop through our connections map and see if
		// there are any missed responses that were overdue for
		// the waiting remote clients.
		// We are creating a code block below to minimize the scope of
		// the mutex locking that we do inside of this forever while loop.
		{
			// Start with an empty result list.
			response_timed_out_handles.clear();
			// Mutex for the safe shared accessing of the client connections map.
			SPL::AutoMutex autoMutex3(wsMutex3);

			for (con_map::iterator it = client_connections_map.begin();
				it != client_connections_map.end(); it++) {
				// it->first points to the key of the map and it->second to the value.
				if(client_connections_map[it->first].responseTimeoutCounter == -1) {
					// No response is pending for this client at this time.
					continue;
				} else {
					// Increment the response time counter by the time we used above to sleep.
					client_connections_map[it->first].responseTimeoutCounter += sleepTimeInSeconds;
				}

				connection_metadata & cmd = client_connections_map[it->first];
				
				// It means, this client is waiting for a response.
				// Let us see if it is still within the configured timeout period.
				if(cmd.responseTimeoutCounter > responseTimeout)  {
					// No response was sent to this client within the expected period.
					// We can do a clean-up and send an informative message to 
					// the remote client about the missed response.
					//
					// Send a short message to the remote client.
					if(cmd.isHttpConnection == false && cmd.isTlsConnection == false) {
						try {
							// This is a non_tls WebSocket based client.
							endpoint_non_tls.send(cmd.hdl, msg, 
								websocketpp::frame::opcode::text);
						} catch (websocketpp::exception const & e) {
							// Do nothing here.
						}
					} else if(cmd.isHttpConnection == false && cmd.isTlsConnection == true) {
						try {
							// This is a TLS WebSocket based client.
							endpoint_tls.send(cmd.hdl, msg,
								websocketpp::frame::opcode::text);
						} catch (websocketpp::exception const & e) {
							// Do nothing here.
						}
					} else if(cmd.isHttpConnection == true && cmd.isTlsConnection == false) {
						// Send a deferred response back to the non_tls HTTP based client.
						// Please read the commentary in the create_new_connection_entry method below
						// to learn why we stored the HTTP connection pointer in con_metadata.
						server_non_tls::connection_ptr con_non_tls = cmd.http_con_non_tls;

						if (con_non_tls != NULL) {
							try {
								// It is a good practice to send a Connection: close header in the 
								// response when we are not keeping a persistent (Keep-Alive) connection. 
								con_non_tls->replace_header(std::string("Connection"),
									std::string("close"));
								con_non_tls->set_body(msg);
								con_non_tls->set_status(websocketpp::http::status_code::im_a_teapot);
								// This is a deferred response to a remote HTTP client.
								con_non_tls->send_http_response(ec);	
							} catch (websocketpp::exception const & e) {
								// Do nothing here.
							}
						}
					} else if(cmd.isHttpConnection == true && cmd.isTlsConnection == true) {
						// Send a deferred response back to the TLS HTTP based client.
						// Please read the commentary in the create_new_connection_entry method below
						// to learn why we stored the HTTP connection pointer in con_metadata.
						server_tls::connection_ptr con_tls = cmd.http_con_tls;
						
						if (con_tls != NULL) {
							try {
								// It is a good practice to send a Connection: close header in the 
								// response when we are not keeping a persistent (Keep-Alive) connection. 
								con_tls->replace_header(std::string("Connection"),
									std::string("close"));
								con_tls->set_body(msg);
								con_tls->set_status(websocketpp::http::status_code::im_a_teapot);
								// This is a deferred response to a remote HTTP client.
								con_tls->send_http_response(ec);	
							} catch (websocketpp::exception const & e) {
								// Do nothing here.
							}
						}
					}
					
					// We can add this connection entry to our list of timed out handles.
					// After this for loop ends, we can do the clean-up below.
					// it->first points to the key of the map and it->second to the value.
					response_timed_out_handles.push_back(it->first);
				} // End of if(cmd.responseTimeoutCounter > responseTimeout)
			} // End of the for loop.
			
			int32_t responseTimedOutCnt =  0;
			
			// Let us now reset the response timeout counter for those timed out handles.
			for (std::list<websocketpp::connection_hdl>::iterator it = response_timed_out_handles.begin(); 
				it != response_timed_out_handles.end(); it++) {
				responseTimedOutCnt++;

				if (wsClientSessionLoggingNeeded == true) {
					connection_metadata & cmd = client_connections_map[*it];
					
					SPLAPPTRC(L_ERROR,
						"Operator "
						<< operatorPhysicalName
						<< "-->Channel " << boost::to_string(udpChannelNumber)
						<< "-->Application response to this client timed out after "
						<< cmd.responseTimeoutCounter
						<< " seconds. It will get reset to -1. If it is a HTTP client, "
						<< "its connection will be closed and its connection entry will be removed. "
						<< "clientSessionId=" << cmd.clientSessionId
						<< ", hdl=" << cmd.hdl.lock().get()
						<< ", remoteEndpoint=" << cmd.remoteEndpoint
						<< ", clientIp=" << cmd.clientIpAddress
						<< ", clientPort=" << cmd.clientPort
						<< ", isTlsConnection=" << cmd.isTlsConnection
						<< ", isHttpConnection=" << cmd.isHttpConnection
						<< ", serverIp=" << cmd.serverIpAddress
						<< ", serverPort=" << cmd.serverPort
						<< ", responseTimeoutCounter=" << cmd.responseTimeoutCounter
						<< ", dataItemsSentCnt=" << cmd.dataItemsSentCnt
						<< ", dataBytesSent=" << cmd.dataBytesSent					
						<< ", nClientsConnected=" << nClientsConnected
						<< ", total data items sent to all clients=" << nDataItemsSentToRemoteClients
						<< ", total data bytes sent to all clients=" << nDataBytesSentToRemoteClients,
						"ws_response_timeout_handler");				
				}
				
				// Reset it to indicate that there is no response pending at this time.
				client_connections_map[*it].responseTimeoutCounter = -1;

				if(client_connections_map[*it].isHttpConnection == true) {
					// If we just now finished dealing with a HTTP based remote client, 
					// then we must do an in-memory clean-up for that client connection.
					// HTTP POST client connections are made fresh for every message exchange.
					// So, we are done with this particular HTTP client connection.
					// Delete this client session id from the map we maintain to do a
					// faster search of a connection handle by using a client session id.
					client_id_to_hdl_map.erase(client_connections_map[*it].clientSessionId);
		
					// Delete this handle from our associative container.        
					client_connections_map.erase(*it);
					
					// We are now with one less client connection.
					nClientsConnected -= 1;
					
					// Update the operator metric only if the user asked for a live update.
					if (websocketLiveMetricsUpdateNeeded == true) {
						nClientsConnectedMetric->setValueNoLock(nClientsConnected);
					}
					
					// Please note that unlike in the on_close for WebSocket connections, we are not
					// going to send an "End of Client Session" signal on output port 1.
					// Because, it will simply be too many of them for the 
					// HTTP based request/response connections.
				}
			} // End of for loop that iterates over the response timed out handles.
			
			if(responseTimedOutCnt > 0) {
				if(wsClientSessionLoggingNeeded == true) {
					SPLAPPTRC(L_ERROR,
						"Operator "
						<< operatorPhysicalName
						<< "-->Channel " << boost::to_string(udpChannelNumber)
						<< ". A total of " <<  responseTimedOutCnt 
						<< " response timeout conditions were detected and the necessary "
						<< "clean-up was completed.", "ws_response_timeout_handler");
				}
				
				nResponseTimeoutOccurrences += responseTimedOutCnt;

				// Update the operator metric only if the user asked for a live update.
				if (websocketLiveMetricsUpdateNeeded == true) {
					nResponseTimeoutOccurrencesMetric->setValueNoLock(nResponseTimeoutOccurrences);
				}
			}
			
			//  We are done.
		} // End of the local block that provides the life scope for wsMutex3.		
	} // End of the outer while loop.
} // End of ws_response_timeout_handler
<%}%>

// Added the following TCP socket init handlers on Jan/29/2023.
//
// This method will be called during non_tls socket init.
// At that time, we can set the required socket options if any.
//
// Type definition for the non-TLS specific socket init handler can be
// found inside this file.
// https://github.com/zaphoyd/websocketpp/blob/master/websocketpp/transport/asio/security/none.hpp
//
void MY_OPERATOR::on_non_tls_socket_init(websocketpp::connection_hdl hdl, 
	boost::asio::ip::tcp::socket & s) {
	// Set user's choice for TCP_NODELAY to control Nagle's algorthim.
	//
	// IMPORTANT CAUTION: Setting TCP options is broken from 
	// websocketpp library versions 0.8.0 to 0.8.2.
	// We can uncomment the following code block and test with
	// version 0.8.3 when it is released to verify if this feature works.
	//
	// Read the full details at this URL.
	// https://github.com/zaphoyd/websocketpp/issues/812
	//
	/*
	boost::asio::ip::tcp::no_delay option(tcpNoDelay);
	s.set_option(option);
	
	SPLAPPTRC(L_ERROR,
		"Operator "
		<< operatorPhysicalName
		<< "-->Channel " << boost::to_string(udpChannelNumber)
		<< "-->I1 Non-TLS Socket Init Handler "
		<< "successfully set TCP_NODELAY to "
		<< tcpNoDelay
		<< ".",
		"on_non_tls_socket_init");
	*/
}

// This method will be called during tls socket init.
// At that time, we can set the required socket options if any.
// The prototype for the handler for TLS takes a slightly different 
// prototype for the second argument which is a socket stream wrapper.
// In the case of non-TLS, it is a straight socket instead of stream wrapper.
//
// It is explained in this post by the websocketpp author.
// https://stackoverflow.com/questions/23023317/proper-set-socket-init-handler-syntax-or-modify-source-to-turn-on-tcp-nodelay-wi
//
// Type definition for the TLS specific socket init handler can be
// found inside this file.
// https://github.com/zaphoyd/websocketpp/blob/master/websocketpp/transport/asio/security/tls.hpp
//
void MY_OPERATOR::on_tls_socket_init(websocketpp::connection_hdl hdl, 
	boost::asio::ssl::stream<boost::asio::ip::tcp::socket> & s) {
	// Set user's choice for TCP_NODELAY to control Nagle's algorthim.
	//
	// IMPORTANT CAUTION: Setting TCP options is broken from 
	// websocketpp library versions 0.8.0 to 0.8.2.
	// We can uncomment the following code block and test with
	// version 0.8.3 when it is released to verify if this feature works.
	//
	// Read the full details at this URL.
	// https://github.com/zaphoyd/websocketpp/issues/812
	//
	/*
	boost::asio::ip::tcp::no_delay option(tcpNoDelay);
	s.lowest_layer().set_option(option);

	SPLAPPTRC(L_ERROR,
		"Operator "
		<< operatorPhysicalName
		<< "-->Channel " << boost::to_string(udpChannelNumber)
		<< "-->I2 TLS Socket Init Handler "
		<< "successfully set TCP_NODELAY to "
		<< tcpNoDelay
		<< ".",
		"on_tls_socket_init");
	*/
}

// This method sets up the TLS for a given client connection handle.
// WebSocket++ library calls this handler ahead of time before a
// new TLS client attempts to connect. It prepares a TLS context
// ahead of time and keeps a spare one to be assigned to the next 
// arriving new WebSocket or a regular https client (wss or https).
// When such a new TLS client connects here, it will be using that
// spare handle throughout its connected life.
MY_OPERATOR::context_ptr MY_OPERATOR::on_tls_init(
		websocketpp::connection_hdl hdl) {
	bool wsSessionLoggingDone = false;

	if (wsClientSessionLoggingNeeded == true) {
		SPLAPPTRC(L_ERROR, "on_tls_init called with hdl: " << hdl.lock().get(),
				"on_tls_init");
		wsSessionLoggingDone = true;
	}

	if (wsSessionLoggingDone == false) {
		SPLAPPTRC(L_INFO, "on_tls_init called with hdl: " << hdl.lock().get(),
				"on_tls_init");
	}

	// TIP: If we want to know which TLS version gets negotiated between the
	// client and the server, we can run this command from a client machine:
	//
	// openssl s_client -connect TLSHost:port
	// openssl s_client -connect b0513:8443
	//
	// You can read more about that command in this URL:
	// https://security.stackexchange.com/questions/100029/how-do-we-determine-the-ssl-tls-version-of-an-http-request
	//
	// We will configure the boost asio server to support only the tlsv12 protocol.
	// We can disable the other SSL, TLS protocol versions in order to 
	// strengthen the security.
	// You can read more details about this from here.
	// https://stackoverflow.com/questions/47096415/how-to-make-boostasio-ssl-server-accept-both-tls-1-1-and-tls-1-2/47097088
	// https://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ssl__context.html
	// https://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ssl__context/method.html
	//
	// As shown in the URL above, we can use one of several TLS context methods such as
	// tlsv1, tlsv1_server, tlsv11, tlsv11_server, tlsv12, tlsv12_server. Using one of these
	// options will start only a server supporting that TLS version. Alternatively, we can simply
	// use tls_server which will allow all the versions i.e. v1, v11 and v12. Then, we can apply the 
	// no_tlsxxx flags to disable a particular tls version as needed.
	context_ptr ctx(
		new boost::asio::ssl::context(boost::asio::ssl::context::tls_server));

	try {
		// We will support only tlsv1.2. Let us disable all the other older 
		// tls versions including the very old ssl v2 and v3 protocols.
		ctx->set_options(
				boost::asio::ssl::context::default_workarounds
						| boost::asio::ssl::context::no_sslv2
						| boost::asio::ssl::context::no_sslv3
						| boost::asio::ssl::context::no_tlsv1
						| boost::asio::ssl::context::no_tlsv1_1
						| boost::asio::ssl::context::single_dh_use);
		ctx->set_password_callback(bind(&MY_OPERATOR::get_private_key_password, this));

		// If the user has configured specific TLS ciphers to be used when
		// establishing the TLS connection, then we can set it now.
		// Reference URLs:
		// https://stackoverflow.com/questions/50058521/using-specific-cipher-for-ssl-tls-in-boostasio
		// https://www.ibm.com/support/knowledgecenter/SSB23S_1.1.0.2020/gtpc2/cpp_ssl_ctx_set_cipher_list.html
		// https://www.ibm.com/support/knowledgecenter/SSB23S_1.1.0.2020/gtps7/s5sple1.html
		if(tlsCipherWhitelist.length() > 0) {
			// e-g: "DES-CBC3-SHA,AES128-SHA,AES256-SHA"
			if (SSL_CTX_set_cipher_list(ctx->native_handle(), 
				tlsCipherWhitelist.c_str()) <= 0) {
				std::cout << "Operator " << operatorPhysicalName <<
					"-->Channel " << boost::to_string(udpChannelNumber) << 
					"-->" << "Error in setting user provided TLS cipher list." << std::endl;
				
				throw std::runtime_error(
					std::string("WebSocketSource_cpp.cgt: Error in on_tls_init: ") +
					"Error in setting user provided TLS cipher list.");			
			}
		}
		
		// Let us now load the server's private key and 
		// public certificate holding PEM file.
		ctx->use_certificate_chain_file(certificateFileName.c_str());
		ctx->use_private_key_file(certificateFileName.c_str(),
			boost::asio::ssl::context::pem);
		
		// If user configured a trustedClientCertificateFileName to perform
		// client (mutual) authentication, then let us do the necessary
		// things in the Boost ASIO library.
		// 
		// Reference URLs:
		// https://stackoverflow.com/questions/25342971/boost-asio-ssl-two-way-authentication
		// https://stackoverflow.com/questions/16890339/how-to-verify-client-certificates-using-boostasio-ssl
		//
		if(trustedClientCertificateFileName != "") {
		   // Load the remote peer's public certificate file and 
		   // keep it ready for client authentication.
		   // If there is any problem in loading that file,
		   // fail and throw an exception.
			ctx->load_verify_file(trustedClientCertificateFileName);
			ctx->set_verify_mode(
				boost::asio::ssl::verify_peer | 
				boost::asio::ssl::verify_fail_if_no_peer_cert);
		   // If the Boost ASIO will not let certain self signed peer
		   // certificates to go through, we can do our own verification for them.
		   // That is what this callback method does.
		   // Reference URL: 
		   // https://www.boost.org/doc/libs/1_52_0/doc/html/boost_asio/example/ssl/client.cpp
		   ctx->set_verify_callback(bind(&MY_OPERATOR::verify_peer_certificate, this, _1, _2));
		   // The following line of code tells the TLS context to use the 
		   // default, system-dependent directories for locating certification 
		   // authority certificates. This will cover all the certificates 
		   // signed by the well known CAs.
		   //
		   // This command will reveal the default path:  openssl version -a
		   // You should see this in the result display of that command.
		   // OPENSSLDIR: "/etc/pki/tls"
		   ctx->set_default_verify_paths();
		}
	} catch (std::exception& e) {
    	std::cout << "Operator " << operatorPhysicalName <<
			"-->Channel " << boost::to_string(udpChannelNumber) << 
			"-->" << e.what() << std::endl;
		
		throw std::runtime_error(
			std::string("WebSocketSource_cpp.cgt: Exception in on_tls_init: ") +
			e.what() +
			". Reason for this error could be an invalid wss, https URL or a " +
			"missing server certificate file or a missing trusted client certificate file or an " +
			"incorrect private key password. Please check.");
	}
	
	return ctx;
} // End of on_tls_init

// This callback happens right before on_open or on_fail.
// This gives us a chance to either accept or reject a non_tls client connection.
bool MY_OPERATOR::validate_non_tls_client(websocketpp::connection_hdl hdl) {
	server_non_tls::connection_ptr server_non_tls_con;
	server_tls::connection_ptr server_tls_con;
	
	// Simply redirect it to a common validate client connection handler by
	// setting the second argument to false to indicate that
	// it is a non_tls WebSocket connection from a client.
	// Third argument is false to indicate that it is not a HTTP/S based connection.
	return(validate_client(hdl, false, false, server_non_tls_con, server_tls_con));
} // End of validate_non_tls_client

// This callback happens right before on_open or on_fail.
// This gives us a chance to either accept or reject a TLS client connection.
bool MY_OPERATOR::validate_tls_client(websocketpp::connection_hdl hdl) {
	server_non_tls::connection_ptr server_non_tls_con;
	server_tls::connection_ptr server_tls_con;
	
	// Simply redirect it to a common validate client connection handler by
	// setting the second argument to true to indicate that
	// it is a TLS WebSocket connection from a client.
	// Third argument is false to indicate that it is not a HTTP/S based connection.
	return(validate_client(hdl, true, false, server_non_tls_con, server_tls_con));
} // End of validate_tls_client

// This is a common validate handler for both the non_tls and TLS new client connections.
// This technique is described in these URLs.
// https://github.com/zaphoyd/websocketpp/issues/422
// https://github.com/zaphoyd/websocketpp/issues/422
// https://www.zaphoyd.com/websocketpp/manual/common-patterns/conditionally-accepting-connections
bool MY_OPERATOR::validate_client(websocketpp::connection_hdl hdl, 
	bool isTlsConnection, bool isHttpConnection,
	server_non_tls::connection_ptr & server_non_tls_con,
	server_tls::connection_ptr & server_tls_con) {
	std::string myUrlContext = "";
	std::string remoteEndpoint = "";
	std::string serverIp = "";
	std::string serverPort = "";
	std::string clientIp = "";
	std::string clientPort = "";
	std::string httpRequestMethod = "";
	
	websocketpp::lib::error_code ec;
	server_non_tls_con = NULL;
	server_tls_con = NULL;

	if (isTlsConnection == false) {
		// Upgrade our connection handle to a full connection_ptr.
		// This connection is through a non_tls HTTP endpoint.
		server_non_tls_con = endpoint_non_tls.get_con_from_hdl(hdl, ec);
		
		if(server_non_tls_con == NULL) {
			if (wsConnectionLoggingNeeded == true) {
				SPLAPPTRC(L_ERROR, 
					"Unable to get a connection pointer from the non_tls connection handle. " <<
					"hdl=" << hdl.lock().get(), "validate_client");
			}
			
			return(false);
		}
		
		remoteEndpoint = server_non_tls_con->get_remote_endpoint();
		serverIp = server_non_tls_con->get_host();
		serverPort = boost::to_string(server_non_tls_con->get_port());
		// Get the context path present in the URL being accessed by this client.
		myUrlContext = server_non_tls_con->get_resource();
		// Get the HTTP request method.
		httpRequestMethod = server_non_tls_con->get_request().get_method();
	} else {
		// Upgrade our connection handle to a full connection_ptr.
		// This connection is through a TLS HTTP endpoint.
		server_tls_con = endpoint_tls.get_con_from_hdl(hdl, ec);
		
		if(server_tls_con == NULL) {
			if (wsConnectionLoggingNeeded == true) {
				SPLAPPTRC(L_ERROR, 
					"Unable to get a connection pointer from the TLS connection handle. " <<
					"hdl=" << hdl.lock().get(), "validate_client");
			}
			
			return(false);
		}
		
		remoteEndpoint = server_tls_con->get_remote_endpoint();
		serverIp = server_tls_con->get_host();
		serverPort = boost::to_string(server_tls_con->get_port());
		// Get the context path present in the URL being accessed by this client.
		myUrlContext = server_tls_con->get_resource();
		// Get the HTTP request method.
		httpRequestMethod = server_tls_con->get_request().get_method();
	}
	
	// If it is a HTTP GET URL, there may be a query string present.
	// Remove the query string part.
	SPL::int32 idx1 = SPL::Functions::String::findFirst(myUrlContext, "?");
	
	if (idx1 != -1) {
		// Query string is present.
		// Get rid of the query string part by taking a substring.
		myUrlContext = SPL::Functions::String::substring(myUrlContext, 0, idx1);
	}	
	
	// Let us check the correctness of the context path provided in
	// the WebSocket server URL being accessed by the remote client.
	//
	// Let us first check if this client is using the correct context path in its URL.
	// If there is no user configured URL context path, then it is an empty string.
	// When the operator has its context path as an empty string, then the client
	// should have simply formed its url as https://host:port (OR) https://host:port/
	// In those two cases, the websocketpp API get_resource() used above will simply 
	// return a forward slash i.e. /     So, we will permit that in the following check.
	// When the user configured url context path is not empty, then we must compare it
	// with what the client is using to connect here. In this case, note below that we
	// are adding a forward slash in front of the user configured url context path.
	SPL::boolean validUrlContextPath = false;
	SPL::int32 numberOfContextPaths = SPL::Functions::Collections::size(urlContextPath);
	
	if(numberOfContextPaths <= 0 && myUrlContext == "/") {
		// Server endpoint has no user configured URL context path.
		// Client also has used an empty context path in the URL.
		// So, it is valid.
		validUrlContextPath = true;
	}
	
	// We can now loop through the URL context path list and do the UCP correctness check.
	// If there are multiple URL context paths configured by the user for the 
	// WebSocket server endpoint, then we should find at least one match in order 
	// for the client provided URL to be valid and passed to the next stage in
	// this client connection validation callback handler.
	for(SPL::int32 cnt = 0; cnt < numberOfContextPaths; cnt++) {
		if(urlContextPath[cnt] == "" && myUrlContext == "/") {
			// Server context path is empty. 
			// Client provided context path is simply a forward slash.
			// So, that is a match and it is valid.
			validUrlContextPath = true;
			break;
		}

		if(urlContextPath[cnt] != "" && myUrlContext == (std::string("/") + urlContextPath[cnt])) {
			// Server context path is not empty.
			// Client provided context path is a forward slash + server's context path.
			// So, that is a match and it is valid.
			validUrlContextPath = true;
			break;
		}
		
		// If it is HTTP GET, it is possible thst the client is requesting a file such as 
		// index.html, image.png etc. In that case, URL will look like this.
		// http://b0513:8080/MyServices/Banking/Deposit/index.html?NY=Albany&CT=Hartford&NJ=Trenton&RI=Providence
		// https://b0513:8443/MyServices/Banking/Deposit/pics/image.jpg
		// In such cases, let us allow this remote HTTP client to go through.
		if(httpRequestMethod == "GET" && urlContextPath[cnt] != "" && 
		   SPL::Functions::String::findFirst(myUrlContext, (std::string("/") + urlContextPath[cnt])) == 0) {
			// This HTTP GET based URL definitely has the required context plus more.
			// That more stuff could be the file name whose contents are being requested by the remote client.
			// e-g: index.html, image.gif etc.
			validUrlContextPath = true;
			break;
		}

		// If it is HTTP GET, it is possible thst the client is requesting a file such as 
		// favicon.ico. In that case, URL will look like this.
		// https://b0513:8443/favicon.ico
		// In such cases, let us allow this remote HTTP client to go through if the user has
		// configured "" as one of the permitted URL context paths.
		if(httpRequestMethod == "GET" && urlContextPath[cnt] == "" && 
		   SPL::Functions::String::findFirst(myUrlContext, (std::string("/") + urlContextPath[cnt])) == 0) {
			// This HTTP GET based URL definitely has the required context plus more.
			// That more stuff could be the file name whose contents are being requested by the remote client.
			// e-g: favicon.ico
			validUrlContextPath = true;
			break;
		}
	} // End of for loop.
	
	if(validUrlContextPath == false) {
		if (wsConnectionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR, 
				"Operator " <<
				operatorPhysicalName <<
				"-->Channel " << boost::to_string(udpChannelNumber) <<
				". Invalid URL context path is being accessed by this client. " <<
				"So, this client can't be allowed to connect at this time. " <<
				"nClientsConnected=" << nClientsConnected << 
				", maxClientConnectionsAllowed=" << maxClientConnectionsAllowed <<
				", hdl=" << hdl.lock().get() << 
				", remoteEndpoint=" << remoteEndpoint <<
				", clientIp=" << clientIp <<
				", clientPort=" << clientPort <<
				", isTlsConnection=" << isTlsConnection <<
				", isHttpConnection=" << isHttpConnection <<
				", serverIp=" << serverIp <<
				", serverPort=" << serverPort <<
				", server's configured URL context path=" << urlContextPath <<
				". client provided URL context path=" << myUrlContext,
				"validate_client");	
		}

		// Send a response back to the client.
		// But, don't send any clue back to the client about the correct url context path.
		// Because, that client may be a malware. Let it find out the correct context on its own.
		std::string body_msg = 
			std::string("Invalid URL context path is being accessed by this client: ") +
			myUrlContext + 
			std::string(". So, this client can't be allowed to connect at this time.");
	
		if (isTlsConnection == false) {
			try {
				server_non_tls_con->set_body(body_msg);
				server_non_tls_con->set_status(websocketpp::http::status_code::forbidden, body_msg);
			} catch (websocketpp::exception const & e) {
				// Do nothing here.
			}
		} else {
			try {
				server_tls_con->set_body(body_msg);
				server_tls_con->set_status(websocketpp::http::status_code::forbidden, body_msg);	
			} catch (websocketpp::exception const & e) {
				// Do nothing here.
			}
		}
		
		return(false);		
	} // End of if(validUrlContextPath == false)
	
	// In my tests, I have seen two different forms of values returned for remoteEndpoint. 
	// We should be prepared to deal with both of those formats.
	// [::ffff:10.6.33.13]:46772        [When ipv6Available operator parameter is set to true]
	// 10.6.33.17:52186                 [When ipv6Available operator parameter is set to false]
	// From that result string, let us parse the client IP and client port.
	SPL::list<SPL::rstring> tokens = 
		SPL::Functions::String::tokenize(remoteEndpoint, ":", true);
	
	if(SPL::Functions::Collections::size(tokens) != 5 &&
	   SPL::Functions::Collections::size(tokens) != 2) {
		// We don't have the correct number of tokens.
		if (wsConnectionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR, 
				"Unable to find all the fileds in the remoteEndpoint result. " <<
				"remoteEndpoint=" << remoteEndpoint << 
				", hdl=" << hdl.lock().get(), "validate_client");
		}
		
		// Send a response back to the client.
		std::string body_msg = "Unable to find all the fileds in the remoteEndpoint result.";
		if (isTlsConnection == false) {
			try {
				server_non_tls_con->set_body(body_msg);
				server_non_tls_con->set_status(websocketpp::http::status_code::forbidden, body_msg);
			} catch (websocketpp::exception const & e) {
				// Do nothing here.
			}
		} else {
			try {
				server_tls_con->set_body(body_msg);
				server_tls_con->set_status(websocketpp::http::status_code::forbidden, body_msg);	
			} catch (websocketpp::exception const & e) {
				// Do nothing here.
			}
		}
		
		return(false);		
	}
	
	if(SPL::Functions::Collections::size(tokens) == 5) {
		// This is in ipv6 format.
		// 4th token has the client IP and the 5th token has the client port.
		clientIp = tokens[3];
		// Trim the last character ']' from the clientIp.
		clientIp = SPL::Functions::String::rtrim(clientIp, std::string("]"));
		clientPort = tokens[4];
	} else {
		// This is in ipv4 format.
		// 1st token has the client IP and the 2nd token has the client port.
		clientIp = tokens[0];
		clientPort = tokens[1];
	}
	
	// If we have reached the max client connections allowed limit, 
	// we can't accept this new client to connect at this time.
	if(nClientsConnected >= maxClientConnectionsAllowed) {
		if (wsConnectionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR, 
				"Operator " <<
				operatorPhysicalName <<
				"-->Channel " << boost::to_string(udpChannelNumber) <<
				". Maximum allowed number of clients are already connected to this operator. " <<
				"A new client with these details can't be allowed to connect at this time. " <<
				"nClientsConnected=" << nClientsConnected << 
				", maxClientConnectionsAllowed=" << maxClientConnectionsAllowed <<
				", hdl=" << hdl.lock().get() << 
				", remoteEndpoint=" << remoteEndpoint <<
				", clientIp=" << clientIp <<
				", clientPort=" << clientPort <<
				", isTlsConnection=" << isTlsConnection <<
				", isHttpConnection=" << isHttpConnection <<
				", serverIp=" << serverIp <<
				", serverPort=" << serverPort, "validate_client");	
		}

		// Send a response back to the client.
		std::string body_msg = "Server is at full capacity. Maximum allowed number of clients are already connected.";
		if (isTlsConnection == false) {
			try {
				server_non_tls_con->set_body(body_msg);
				server_non_tls_con->set_status(websocketpp::http::status_code::forbidden, body_msg);
			} catch (websocketpp::exception const & e) {
				// Do nothing here.
			}
		} else {
			try {
				server_tls_con->set_body(body_msg);
				server_tls_con->set_status(websocketpp::http::status_code::forbidden, body_msg);	
			} catch (websocketpp::exception const & e) {
				// Do nothing here.
			}
		}
		
		return(false);
	}
	
	// Parse the remote client's IP address into four individual parts.
	SPL::list<SPL::rstring> clientIpParts = 
		SPL::Functions::String::tokenize(clientIp, ".", true);
	
	if(SPL::Functions::Collections::size(clientIpParts) != 4) {
		// We couldn't correctly parse this client's IP address.
		if (wsConnectionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR,
				"Operator " <<
				operatorPhysicalName <<
				"-->Channel " << boost::to_string(udpChannelNumber) <<
				". Unable to correctly parse the IP address of a remote client that is trying to connect. " <<
				"nClientsConnected=" << nClientsConnected << 
				", maxClientConnectionsAllowed=" << maxClientConnectionsAllowed <<
				", hdl=" << hdl.lock().get() << 
				", remoteEndpoint=" << remoteEndpoint <<
				", clientIp=" << clientIp <<
				", clientPort=" << clientPort <<
				", isTlsConnection=" << isTlsConnection <<
				", isHttpConnection=" << isHttpConnection <<
				", serverIp=" << serverIp <<
				", serverPort=" << serverPort, "validate_client");	
		}

		// Send a response back to the client.
		std::string body_msg = "Unable to correctly parse the IP address of a remote client.";
		if (isTlsConnection == false) {
			try {
				server_non_tls_con->set_body(body_msg);
				server_non_tls_con->set_status(websocketpp::http::status_code::forbidden, body_msg);
			} catch (websocketpp::exception const & e) {
				// Do nothing here.
			}
		} else {
			try {
				server_tls_con->set_body(body_msg);
				server_tls_con->set_status(websocketpp::http::status_code::forbidden, body_msg);
			} catch (websocketpp::exception const & e) {
				// Do nothing here.
			}
		}

		return(false);
	}

	// There are multiple methods (process and validate_client) that
	// access (read, write) the client whitelist member variable.
	// All those methods work in parallel inside their own threads.
	// To make that list access to be thread safe, we will use this mutex.
	SPL::AutoMutex autoMutex2(wsMutex2);	
	SPL::int32 whitelistCnt = SPL::Functions::Collections::size(clientWhitelist);
	
	if(whitelistCnt <= 0) {
		// There is no client whitelist.
		// So, all clients can connect here without any restrictions.
		return(true);
	}
	
	// There is a client whitelist available. We can check if this new client is present in that whitelist.
	// IP addresses in that whitelist can be exact or wildcard based as shown below.
    // clientWhitelist: ['172.34.18.212', '10.5.23.17', '172.*.42.*', '10.29.42.*'];
	for(SPL::int32 cnt = 0; cnt < whitelistCnt; cnt++) {
		// Get the next available whitelist entry.
		SPL::rstring allowedIp = clientWhitelist[cnt];
		// Parse this entry's Ip address into four individual parts.
		SPL::list<SPL::rstring> allowedIpParts = 
			SPL::Functions::String::tokenize(allowedIp, ".", true);
		
		if(SPL::Functions::Collections::size(allowedIpParts) != 4) {
			// Not enough parts available for this entry to be useful to us.
			// Skip this one and continue with the loop.
			continue;
		}
		
		// Let us now validate to see if the remote client IP is allowed to connect.
		// Check to see if part 1, part 2, part 3 and part 4 have either
		// wildcard or a match.
		if ((allowedIpParts[0] == "*" || clientIpParts[0] == allowedIpParts[0]) &&
			(allowedIpParts[1] == "*" || clientIpParts[1] == allowedIpParts[1]) &&
			(allowedIpParts[2] == "*" || clientIpParts[2] == allowedIpParts[2]) &&
			(allowedIpParts[3] == "*" || clientIpParts[3] == allowedIpParts[3])) {
			// This remote client has a match in the whitelist. Let us allow it.
			return(true);
		}
	} // End of the for loop.
	
	// If we reached here, this client is not allowed to connect.
	if (wsConnectionLoggingNeeded == true) {
		SPLAPPTRC(L_ERROR, 
			"Operator " <<
			operatorPhysicalName <<
			"-->Channel " << boost::to_string(udpChannelNumber) <<
			". This remote client is not in the whitelist. So, it can't be allowed to connect. " <<
			"nClientsConnected=" << nClientsConnected << 
			", maxClientConnectionsAllowed=" << maxClientConnectionsAllowed <<
			", hdl=" << hdl.lock().get() << 
			", remoteEndpoint=" << remoteEndpoint <<
			", clientIp=" << clientIp <<
			", clientPort=" << clientPort <<
			", isTlsConnection=" << isTlsConnection <<
			", isHttpConnection=" << isHttpConnection <<
			", serverIp=" << serverIp <<
			", serverPort=" << serverPort, "validate_client");	
	}

	// Send a response back to the client.
	std::string body_msg = "Remote client is not in the whitelist. So, it can't be allowed to connect.";
	if (isTlsConnection == false) {
		try {
			server_non_tls_con->set_body(body_msg);
			server_non_tls_con->set_status(websocketpp::http::status_code::unauthorized, body_msg);
		} catch (websocketpp::exception const & e) {
			// Do nothing here.
		}
	} else {
		try {
			server_tls_con->set_body(body_msg);
			server_tls_con->set_status(websocketpp::http::status_code::unauthorized, body_msg);	
		} catch (websocketpp::exception const & e) {
			// Do nothing here.
		}
	}
	
	return(false);	
} // End of validate_client

// When a client establishes a new non_tls Websocket connection, this callback method is run.
void MY_OPERATOR::on_open_non_tls(websocketpp::connection_hdl hdl) {
	// Let us redirect this to the common on_open handler by
	// setting the second argument to false to indicate that
	// it is a non_tls WebSocket connection from a client.
	on_open(hdl, false);
} // End of on_open_non_tls

// When a client establishes a new TLS Websocket connection, this callback method is run.
void MY_OPERATOR::on_open_tls(websocketpp::connection_hdl hdl) {
	// Let us redirect this to the common on_open handler by
	// setting the second argument to true to indicate that
	// it is a TLS WebSocket connection from a client.
	on_open(hdl, true);
} // End of on_open_tls.

// This is a common on_open handler for both the non_tls and TLS new client connections.
void MY_OPERATOR::on_open(websocketpp::connection_hdl hdl, bool isTlsConnection) {
	// Mutex for the safe shared accessing of the client connections map.
	SPL::AutoMutex autoMutex3(wsMutex3);

	websocketpp::lib::error_code ec;
	server_non_tls::connection_ptr server_non_tls_con = NULL;
	server_tls::connection_ptr server_tls_con = NULL;

	if (isTlsConnection == false) {
		// Upgrade our connection handle to a full connection_ptr.
		// This connection is through a non_tls HTTP endpoint.
		server_non_tls_con = endpoint_non_tls.get_con_from_hdl(hdl, ec);
		
		if(server_non_tls_con == NULL) {
			if (wsConnectionLoggingNeeded == true) {
				SPLAPPTRC(L_ERROR, 
					"Unable to get a connection pointer from the non_tls connection handle. " <<
					"hdl=" << hdl.lock().get(), "on_open");
			}
		}		
	} else {
		// Upgrade our connection handle to a full connection_ptr.
		// This connection is through a TLS HTTP endpoint.
		server_tls_con = endpoint_tls.get_con_from_hdl(hdl, ec);
		
		if(server_tls_con == NULL) {
			if (wsConnectionLoggingNeeded == true) {
				SPLAPPTRC(L_ERROR, 
					"Unable to get a connection pointer from the TLS connection handle. " <<
					"hdl=" << hdl.lock().get(), "on_open");
			}
		}
	}
	
	
	// A new WebSocket connection from a remote client.
	// Creae a new connection entry in our associate container.
	// Third argument is set to false to indicate that it is not a HTTP/S based connection.
	// Fourth and fifth arguments are only needed for a HTTP client and not for a
	// WebSocket client. Read more details about it inside the method being called here.
	create_new_connection_entry(hdl, isTlsConnection, false, 
		server_non_tls_con, server_tls_con, std::string("on_open"));
} // End of on_open.

// The shared on_message handler takes a template parameter so the function can
// resolve any endpoint dependent types like message_ptr or connection_ptr
template<typename EndpointType>
void MY_OPERATOR::on_message(EndpointType* s, websocketpp::connection_hdl hdl,
		typename EndpointType::message_ptr msg) {
	int32_t payloadSize = msg->get_payload().size();
	
	if (payloadSize <= 0) {
		// Nothing was sent in the payload. Ignore it.
		return;
	}
	
	// Mutex for the safe shared accessing of the client connections map.
	SPL::AutoMutex autoMutex3(wsMutex3);
	// Note that we can't use a reference here without assigning it to a proper initial value.
	connection_metadata con_metadata;
	
	try {
		// Get the metadata details for this connection handle from our client connections map.
		con_metadata = get_con_metadata_from_hdl(hdl);
	} catch (const std::invalid_argument & e) {
		if (wsClientSessionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
				"-->Channel " << boost::to_string(udpChannelNumber) << 
				"-->hdl=" << hdl.lock().get() <<
				". Unable to get con_metadata-->" << e.what(), "on_message");
		}
		
		return;
	} catch (...) {
		if (wsClientSessionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
				"-->Channel " << boost::to_string(udpChannelNumber) << 
				"-->hdl=" << hdl.lock().get() <<
				". Unable to get con_metadata-->Other exception occurred.", "on_message");
		}
		
		return;
	}
	
	bool wsSessionLoggingDone = false;

	if (wsClientSessionLoggingNeeded == true) {
		SPLAPPTRC(L_ERROR,
			"on_message called with hdl: " << hdl.lock().get()
			<< " with a message size of: "
			<< payloadSize << " bytes.",
			"on_message");
		wsSessionLoggingDone = true;
	}

	if (wsSessionLoggingDone == false) {
		SPLAPPTRC(L_INFO,
			"on_message called with hdl: " << hdl.lock().get()
			<< " with a message size of: "
			<< payloadSize << " bytes.",
			"on_message");
	}

	// If it is the very first time we are getting a message from a client after it
	// opened a connection with us, let us transition its status now.
	if (con_metadata.wsSessionStatus == CLIENT_OPENED_A_WS_CONNECTION) {
		// At this point, we can claim that the remote client started a  
		// WebSocket session. So, we can transition this connection's 
		// status to the next logical state.
		con_metadata.wsSessionStatus = CLIENT_STARTED_A_WS_SESSION;
		// Update it in the client connections map.
		client_connections_map[hdl] = con_metadata;

		if (wsClientSessionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR,
				"Operator " << operatorPhysicalName << "-->Channel "
				<< boost::to_string(udpChannelNumber)
				<< "-->hdl=" << hdl.lock().get()
				<< "-->clientSessionId=" << con_metadata.clientSessionId
				<< "-->remoteEndpoint=" << con_metadata.remoteEndpoint
				<< "-->clientIp=" << con_metadata.clientIpAddress
				<< "-->clientPort=" << con_metadata.clientPort
				<< "-->isTlsConnection=" << con_metadata.isTlsConnection 
				<< "-->isHttpConnection=" << con_metadata.isHttpConnection 
				<< "-->serverIp=" << con_metadata.serverIpAddress
				<< "-->serverPort=" << con_metadata.serverPort				
				<< "-->X1 Received and processed the first message in a new session for a client.",
				"on_message");
		}

		// At this time, we will also check for any stale client connections and try to close them.
		if (websocketStaleConnectionPurgeInterval > 0) {
			// PERIODIC STALE CLIENT CONNECTION REMOVAL.
			// In most application scenarios, this feature will not be used at all.
			// Because, any connection closure by client or server or other network effects
			// will always make the underlying websocketpp layer to trigger the 
			// on_close event handler which will do the correct clean-up in our
			// client connection map. So, most users need not worry about this feature at all.
			// They can keep it disabled or set the purge interval to may be 10 years.
			// This feature is useful only in scenarios where there is absolute certainty that
			// a given client should not be there for more than let us say two days.
			// e-g: A call center VOIP client sending data of a customer speech can 
			// no way last for two days.
			// In such scenarios, one may want to use this feature. Otherwise, let it simply
			// exist in this operator without getting used at all.
			//
			// Do this only if the user provided a non-zero purge interval.
			int64_t currentTimeInSeconds = 
				SPL::Functions::Time::getSeconds(SPL::Functions::Time::getTimestamp());

			if (currentTimeInSeconds - timeOfPreviousStaleConnectionRemoval
				>= websocketStaleConnectionPurgeInterval) {
				int32_t staleConnectionsRemovedCnt = 0;
				std::string closeReason =
					std::string("This client has been connected here for very long. ") +
					std::string("So streamsx.websocket is closing this connection");
				websocketpp::lib::error_code ec;
				
				// Let us now check the client connections map.
				// Stale entries happening in this map is a rarity just because
				// on_close handler almost always gets invoked during the
				// normal as well as abnormal client connection closures.
				// This feature must be used only in extremely rare situations. 
				// Unless otherwise needed, simply ignore this feature.
				for (con_map::iterator it = client_connections_map.begin();
					it != client_connections_map.end(); it++) {
					connection_metadata & cmd = it->second;

					if (currentTimeInSeconds - cmd.wsSessionStartTime > websocketStaleConnectionPurgeInterval) {
						// This is a stale connection entry. 
						// Properly close this client's connection now.					
						// This connection closing technique is discussed in these URLs:
						// https://stackoverflow.com/questions/25260852/shut-down-websocket-connection
						// https://github.com/zaphoyd/websocketpp/issues/803
						// https://mayaposch.wordpress.com/2015/09/16/creating-a-websocket-server-with-websocket/
						//
						// IMPORTANT
						// ---------
						// Even though it is a forceful client connection termination done from the server side, 
						// there will still be triggers into the on_close callback method that appears below 
						// in this class. So, all the connection meta data cleanup will be taken care of 
						// inside that method. We will only focus here on closing the client connection.
						if(cmd.isTlsConnection == false) {
							endpoint_non_tls.close(it->first, websocketpp::close::status::normal,
								closeReason, ec);
						} else {
							endpoint_tls.close(it->first, websocketpp::close::status::normal,
								closeReason, ec);
						}
						
						staleConnectionsRemovedCnt++;
					}
				} // End of for loop.

				if (wsClientSessionLoggingNeeded == true && staleConnectionsRemovedCnt > 0) {
					SPLAPPTRC(L_ERROR,
						"Operator " << operatorPhysicalName
						<< "-->Channel "
						<< boost::to_string(udpChannelNumber)
						<< "-->hdl=" << hdl.lock().get()
						<< "-->X4 Removed a few stale client connection handles. Removed count="
						<< staleConnectionsRemovedCnt, "on_message");
				}

				// Set it to the current time so that we can do our next 
				// stale connection removal at the required time interval.
				timeOfPreviousStaleConnectionRemoval = currentTimeInSeconds;
			}
		} // End of if (websocketStaleConnectionPurgeInterval > 0)
	} // End of if (con_metadata.wsSessionStatus == CLIENT_OPENED_A_WS_CONNECTION)

	// We can't accept the data coming from this client without that client going through the
	// proper state transition from CLIENT_OPENED_A_WS_CONNECTION to CLIENT_STARTED_A_WS_SESSION.
	// Possibility of this happening is extremely rare.
	if(con_metadata.wsSessionStatus != CLIENT_STARTED_A_WS_SESSION) {
		if (wsClientSessionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR,
				"Operator " << operatorPhysicalName << "-->Channel "
				<< boost::to_string(udpChannelNumber)
				<< "-->hdl=" << hdl.lock().get()
				<< "-->clientSessionId=" << con_metadata.clientSessionId
				<< "-->remoteEndpoint=" << con_metadata.remoteEndpoint
				<< "-->clientIp=" << con_metadata.clientIpAddress
				<< "-->clientPort=" << con_metadata.clientPort
				<< "-->isTlsConnection=" << con_metadata.isTlsConnection 
				<< "-->isHttpConnection=" << con_metadata.isHttpConnection 
				<< "-->serverIp=" << con_metadata.serverIpAddress
				<< "-->serverPort=" << con_metadata.serverPort		
				<< "-->X5 Received a text or binary based message from a client and " 
				<< "ignored it because there is no valid connection from this remote client.",
				"on_message");
		}
		
		return;
	}

	std::stringstream ss;
	ss << std::string("");
	// Create an SPL blob type.
	SPL::blob myBlob;
	bool isBinaryData = false;
	
	// A WebSocket client connecting to this source operator can send messages via a given client connection
	// either with textual data or with binary data. 
	// Let us first determine if the received message contains textual or binary data.
	if (msg->get_opcode() == websocketpp::frame::opcode::text) {
		// We can't accept text based data if there is no 
		// text based attribute present in the output tuple.
		if (dataOutputAsRString == false) {
			if (wsClientSessionLoggingNeeded == true) {
				SPLAPPTRC(L_ERROR,
					"Operator " << operatorPhysicalName << "-->Channel "
					<< boost::to_string(udpChannelNumber)
					<< "-->hdl=" << hdl.lock().get()
					<< "-->clientSessionId=" << con_metadata.clientSessionId
					<< "-->remoteEndpoint=" << con_metadata.remoteEndpoint
					<< "-->clientIp=" << con_metadata.clientIpAddress
					<< "-->clientPort=" << con_metadata.clientPort
					<< "-->isTlsConnection=" << con_metadata.isTlsConnection 
					<< "-->isHttpConnection=" << con_metadata.isHttpConnection 
					<< "-->serverIp=" << con_metadata.serverIpAddress
					<< "-->serverPort=" << con_metadata.serverPort		
					<< "-->X6 Received a text based message from a client and " 
					<< "ignored it because of no 'rstring strData' attribute present in the output tuple.",
					"on_message");
			}
			
			return;
		}

		// We will receive the text data and send it on this
		// operator's first output port for consumption by the other
		// downstream operators in the application flow graph.		
		ss << msg->get_payload();
	} // End of if (msg->get_opcode() == websocketpp::frame::opcode::text)
	
	// Check if the remote client sent us binary data.
	if (msg->get_opcode() == websocketpp::frame::opcode::binary) {
		// We can't accept binary based data if there is no 
		// blob based attribute present in the output tuple.
		if (dataOutputAsBlob == false) {
			if (wsClientSessionLoggingNeeded == true) {
				SPLAPPTRC(L_ERROR,
					"Operator " << operatorPhysicalName << "-->Channel "
					<< boost::to_string(udpChannelNumber)
					<< "-->hdl=" << hdl.lock().get()
					<< "-->clientSessionId=" << con_metadata.clientSessionId
					<< "-->remoteEndpoint=" << con_metadata.remoteEndpoint
					<< "-->clientIp=" << con_metadata.clientIpAddress
					<< "-->clientPort=" << con_metadata.clientPort
					<< "-->isTlsConnection=" << con_metadata.isTlsConnection 
					<< "-->isHttpConnection=" << con_metadata.isHttpConnection 
					<< "-->serverIp=" << con_metadata.serverIpAddress
					<< "-->serverPort=" << con_metadata.serverPort		
					<< "-->X7 Received a blob based message from a client and " 
					<< "ignored it because of no 'blob blobData' attribute present in the output tuple.",
					"on_message");
			}
			
			return;
		}

		// We will receive the binary data and send it on this
		// operator's first output port for consumption by the other
		// downstream operators in the application flow graph.
		// In WebSocket++, payload is in std::string format for both
		// text and binary data. So, we can get the binary buffer from
		// that string payload. This idea is discussed in this URL:
		// https://github.com/zaphoyd/websocketpp/issues/412
		//
		// Let us create an output tuple and send it out.
		// This transfers (copies) the payload data buffer into the 
		// internal buffer held by the blob. 
		// The blob owns the copied data in memory.
		myBlob.setData((unsigned char*)msg->get_payload().data(), (uint64_t)payloadSize);	
		isBinaryData = true;
	} // End of if (msg->get_opcode() == websocketpp::frame::opcode::binary)

	// We have a valid message from the remote websocket client.
	// Let us submit it now on the first output port of this operator.
	// Final three arguments to this method call are about the
	// HTTP request method name, url query string and a string carrying the 
	// HTTP request headers. This is a WebSocket based message exchange. 
	// So, there is no applicability of those arguments here.
	submit_received_data_item(isBinaryData, payloadSize,
		ss.str(), myBlob, hdl, con_metadata, "", "", "");
	
	if (wsClientSessionLoggingNeeded == true) {
		SPLAPPTRC(L_ERROR,
			"Operator "
			<< operatorPhysicalName
			<< "-->Channel " << boost::to_string(udpChannelNumber)
			<< "-->X2 Received data from a remote client "
			<< "and sent it via an output tuple. "
			<< "clientSessionId=" << con_metadata.clientSessionId
			<< ", hdl=" << con_metadata.hdl.lock().get()
			<< ", remoteEndpoint=" << con_metadata.remoteEndpoint
			<< ", clientIp=" << con_metadata.clientIpAddress
			<< ", clientPort=" << con_metadata.clientPort
			<< ", isTlsConnection=" << con_metadata.isTlsConnection
			<< ", isHttpConnection=" << con_metadata.isHttpConnection
			<< ", serverIp=" << con_metadata.serverIpAddress
			<< ", serverPort=" << con_metadata.serverPort
			<< ", currentDataPacketSize=" << payloadSize
			<< ", dataItemsReceivedCnt=" << con_metadata.dataItemsReceivedCnt
			<< ", dataBytesReceived=" << con_metadata.dataBytesReceived					
			<< ", nClientsConnected=" << nClientsConnected
			<< ", total data items received from all clients=" << nDataItemsReceivedFromRemoteClients
			<< ", total data bytes received from all clients=" << nDataBytesReceivedFromRemoteClients,
			"on_message");
	}
	
	// If this operator is configured to send an acknowledgement to the remote client after
	// receiving certain number of messages, let us do that now.
	if (numberOfMessagesToReceiveBeforeAnAck > 0) {
		if (con_metadata.dataItemsReceivedCnt % numberOfMessagesToReceiveBeforeAnAck == 0) {
			// Time to send an acknowledgement back to this client.
			try {
				char buf[520];
				sprintf(buf, "%d", numberOfMessagesToReceiveBeforeAnAck);
				std::string response = "Ack. Received messages count: " + std::string(buf);
				s->send(hdl, response, websocketpp::frame::opcode::text);
			} catch (websocketpp::exception const & e) {
				SPLAPPTRC(L_ERROR, "Failure while sending an ack to the remote client." 
					<< "-->hdl=" << hdl.lock().get()
					<< "-->clientSessionId=" << con_metadata.clientSessionId
					<< "-->remoteEndpoint=" << con_metadata.remoteEndpoint
					<< "-->clientIp=" << con_metadata.clientIpAddress
					<< "-->clientPort=" << con_metadata.clientPort
					<< "-->isTlsConnection=" << con_metadata.isTlsConnection 
					<< "-->isHttpConnection=" << con_metadata.isHttpConnection 
					<< "-->serverIp=" << con_metadata.serverIpAddress
					<< "-->serverPort=" << con_metadata.serverPort		
					<< " -->Error= (" << e.what() << ")", "on_message");
				// In this case, the remote client can try to send the messages again.
		    }			
		}
	}
} // End of on_message

// When a client's established connection closes, this callback method is run.
void MY_OPERATOR::on_close(websocketpp::connection_hdl hdl) {
	// Mutex for the safe shared accessing of the client connections map.
	SPL::AutoMutex autoMutex3(wsMutex3);
	// Note that we can't use a reference here without assigning it to a proper initial value.
	connection_metadata con_metadata;
	
	try {
		// Get the metadata details for this connection handle from our client connections map.
		con_metadata = get_con_metadata_from_hdl(hdl);
	} catch (const std::invalid_argument & e) {
		if (wsClientSessionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
				"-->Channel " << boost::to_string(udpChannelNumber) << 
				"-->hdl=" << hdl.lock().get() <<
				".  Unable to get con_metadata-->" << e.what(), "on_close");
		}
		
		return;
	} catch (...) {
		if (wsClientSessionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
				"-->Channel " << boost::to_string(udpChannelNumber) << 
				"-->hdl=" << hdl.lock().get() <<
				". Unable to get con_metadata-->Other exception occurred.", "on_close");
		}
		
		return;
	}
	
	int64_t currentTimeInSeconds =
		SPL::Functions::Time::getSeconds(SPL::Functions::Time::getTimestamp());
	int64_t sessionDuration = currentTimeInSeconds - con_metadata.wsSessionStartTime;

	bool wsSessionLoggingDone = false;

	if (wsClientSessionLoggingNeeded == true) {
		SPLAPPTRC(L_ERROR, "on_close called for hdl: " 
			<< hdl.lock().get() 
			<< "-->clientSessionId=" << con_metadata.clientSessionId
			<< "-->remoteEndpoint=" << con_metadata.remoteEndpoint
			<< "-->clientIp=" << con_metadata.clientIpAddress
			<< "-->clientPort=" << con_metadata.clientPort
			<< "-->isTlsConnection=" << con_metadata.isTlsConnection 
			<< "-->isHttpConnection=" << con_metadata.isHttpConnection 
			<< "-->serverIp=" << con_metadata.serverIpAddress 
			<< "-->serverPort=" << con_metadata.serverPort			
			<< "-->sessionDuration=" 
			<< sessionDuration 
			<< " seconds.",
			"on_close");

		wsSessionLoggingDone = true;
	}

	if (wsSessionLoggingDone == false) {
		SPLAPPTRC(L_INFO, "on_close called for hdl: "
			<< hdl.lock().get() 
			<< "-->clientSessionId=" << con_metadata.clientSessionId
			<< "-->remoteEndpoint=" << con_metadata.remoteEndpoint
			<< "-->clientIp=" << con_metadata.clientIpAddress
			<< "-->clientPort=" << con_metadata.clientPort
			<< "-->isTlsConnection=" << con_metadata.isTlsConnection 
			<< "-->isHttpConnection=" << con_metadata.isHttpConnection 
			<< "-->serverIp=" << con_metadata.serverIpAddress
			<< "-->serverPort=" << con_metadata.serverPort			
			<< "-->sessionDuration=" 
			<< sessionDuration 
			<< " seconds.",
			"on_close");
	}

	nClientsConnected -= 1;

	// Update the operator metric only if the user asked for a live update.
	if (websocketLiveMetricsUpdateNeeded == true) {
		nClientsConnectedMetric->setValueNoLock(nClientsConnected);
	}						

	// Send the "End of Client Session" signal now for this client session.
	OPort1Type oTuple;
	oTuple.set_clientSessionId(con_metadata.clientSessionId);
	submit(oTuple, 1);
	
	if (wsClientSessionLoggingNeeded == true) {
		SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName 
			<< "-->Channel " << boost::to_string(udpChannelNumber)
			<< "-->X3 Sent an 'End of Client Session' signal for clientSessionId=" 
			<< con_metadata.clientSessionId
			<< "-->hdl=" << hdl.lock().get() 
			<< "-->clientSessionId=" << con_metadata.clientSessionId
			<< "-->remoteEndpoint=" << con_metadata.remoteEndpoint
			<< "-->clientIp=" << con_metadata.clientIpAddress
			<< "-->clientPort=" << con_metadata.clientPort
			<< "-->isTlsConnection=" << con_metadata.isTlsConnection 
			<< "-->isHttpConnection=" << con_metadata.isHttpConnection 
			<< "-->serverIp=" << con_metadata.serverIpAddress
			<< "-->serverPort=" << con_metadata.serverPort,
			"on_close");
	}		
	
	if (wsSessionLoggingDone == false) {
		SPLAPPTRC(L_INFO, "Operator " << operatorPhysicalName 
				<< "-->Channel " << boost::to_string(udpChannelNumber)
				<< "-->X3 Sent an 'End of Client Session' signal for clientSessionId=" 
				<< con_metadata.clientSessionId
				<< "-->hdl=" << hdl.lock().get() 
				<< "-->clientSessionId=" << con_metadata.clientSessionId
				<< "-->remoteEndpoint=" << con_metadata.remoteEndpoint
				<< "-->clientIp=" << con_metadata.clientIpAddress
				<< "-->clientPort=" << con_metadata.clientPort
				<< "-->isTlsConnection=" << con_metadata.isTlsConnection 
				<< "-->isHttpConnection=" << con_metadata.isHttpConnection 
				<< "-->serverIp=" << con_metadata.serverIpAddress
				<< "-->serverPort=" << con_metadata.serverPort,
				"on_close");
	}

	if (wsConnectionLoggingNeeded == true) {
		SPLAPPTRC(L_ERROR, 
			"Operator " <<
			operatorPhysicalName <<
			"-->Channel " << boost::to_string(udpChannelNumber) <<
			". This remote client closed its connection. " <<
			"clientSessionId=" << con_metadata.clientSessionId << 
			", hdl=" << con_metadata.hdl.lock().get() << 
			", remoteEndpoint=" << con_metadata.remoteEndpoint <<
			", clientIp=" << con_metadata.clientIpAddress <<
			", clientPort=" << con_metadata.clientPort <<
			", isTlsConnection=" << con_metadata.isTlsConnection <<
			", isHttpConnection=" << con_metadata.isHttpConnection <<
			", serverIp=" << con_metadata.serverIpAddress <<
			", serverPort=" << con_metadata.serverPort <<
			", dataItemsReceivedCnt=" << con_metadata.dataItemsReceivedCnt << 
			", dataBytesReceived=" << con_metadata.dataBytesReceived << 				
			", dataItemsSentCnt=" << con_metadata.dataItemsSentCnt << 
			", dataBytesSent=" << con_metadata.dataBytesSent << 				
			", nClientsConnected=" << nClientsConnected << 
			", maxClientConnectionsAllowed=" << maxClientConnectionsAllowed,
			"on_close");	
	}	
	
	// Delete this client session id from the map we maintain to do a
	// faster search of a connection handle by using a client session id.
	client_id_to_hdl_map.erase(con_metadata.clientSessionId);

	// Delete this handle from our associative container.        
	client_connections_map.erase(hdl);
} // End of on_close.

// This is a callback that can return a password if the 
// server-side key file is configured with a key password to be
// provided at the time of loading it in the on_tls_init method.
std::string MY_OPERATOR::get_private_key_password() {
	return (certificatePassword);
}

// Boost ASIO will not allow or pass the self-signed peer  
// certificate verification registered inside the on_tls_init method.
// Because of that, TLS handshake will fail.
// We can use this callback to verify the presence of any application-specific 
// string in a peer's public certificate's subject field.
// This string could be any sub-field such as the CN or OU or an email address or the entire subject.
// 
// Following are some examples of the subject line as it appears in an X509 public certificate.
// /C=US/ST=NY/L=Yorktown Heights/O=IBM/OU=AI/CN=websocket.streams/emailAddress=websocket.streams@ibm.com
// /C=US/O=Let's Encrypt/CN=Let's Encrypt Authority X3
// /C=BE/O=GlobalSign nv-sa/CN=GlobalSign CloudSSL CA - SHA256 - G3
// /C=US/O=Google Trust Services/CN=GTS CA 1O1
// /C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert Global Root CA
// /C=US/ST=New York/L=Armonk/O=IBM/CN=www.ibm.com
//
// Reference URL: 
// https://www.boost.org/doc/libs/1_52_0/doc/html/boost_asio/example/ssl/client.cpp
bool MY_OPERATOR::verify_peer_certificate(bool preverified, 
	boost::asio::ssl::verify_context & ctx) {
    // This verify callback can be used to check whether the certificate that is
    // being presented is valid for the peer. For example, RFC 2818 describes
    // the steps involved in doing this for HTTPS. Consult the OpenSSL
    // documentation for more details. Note that the callback is called once
    // for each certificate in the certificate chain, starting from the root
    // certificate authority.

    char subject_name[1024];
    X509* cert = X509_STORE_CTX_get_current_cert(ctx.native_handle());
    X509_NAME_oneline(X509_get_subject_name(cert), subject_name, 1024);
    
    if(preverified == true) {
    	// This certificae passed the verification most likely for 
    	// being signed by a well known CA.
		if (wsConnectionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR, "V1 Operator " << operatorPhysicalName <<
				"-->Channel " << boost::to_string(udpChannelNumber) <<
				"-->Skipping the subject field match in a peer's public certificate=" <<
				"-->Full subject field=" << std::string(subject_name) <<
				"-->Verified=" << preverified, "verify_peer_certificate");
		}
	
		return(preverified);
	}    
    
    // If there are any self signed peer certificates, they are on a path to get
    // rejected. We will intervene here and see if we can accept them based on the
    // user configured X509 subject line identifiers.
    // We will permit certificates carrying the user defined identifiers to go through.
    SPL::int32 listCnt = 
    	SPL::Functions::Collections::size(trustedClientX509SubjectIdentifiers);
    
    // If user has configured any X509 identifiers, we will try to match them here.
    for(SPL::int32 cnt = 0; cnt < listCnt; cnt++) {
    	if(SPL::Functions::String::findFirst(std::string(subject_name), 
    		trustedClientX509SubjectIdentifiers[cnt]) != -1) {
        	// This is a permitted certificate based on user's configuration.
            if (wsConnectionLoggingNeeded == true) {
            	SPLAPPTRC(L_ERROR, "V2 Operator " << operatorPhysicalName <<
            		"-->Channel " << boost::to_string(udpChannelNumber) <<
        			"-->Matching subject token found in a peer's public certificate=" <<
					trustedClientX509SubjectIdentifiers[cnt] << 
        			"-->Full subject field=" << std::string(subject_name) <<
    				"-->Verified=1", "verify_peer_certificate");
            }
            
        	return(true);
    	}
    } // End of for loop.
    
    // It is getting rejected.
    SPLAPPTRC(L_ERROR, "V3 Operator " << operatorPhysicalName <<
		"-->Channel " << boost::to_string(udpChannelNumber) <<
		"-->Remote client's public certificate failed to verify during tls_init." <<
		"-->Full subject field=" << std::string(subject_name), "verify_peer_certificate");
    
    return(preverified);
} // End of verify_peer_certificate.

// When a client opens a HTTP connection to our WebSocket endpoint, this callback method is run.
// We will process HTTP POST messages carrying a text payload or binary payload.
// 
// This idea of using a HTTP handler along with the regular
// header-only websocketpp features are described in these URLs below.
// https://github.com/zaphoyd/websocketpp/issues/266
// https://github.com/zaphoyd/websocketpp/issues/425
// https://www.zaphoyd.com/websocketpp/manual/reference/handler-list/httphandler
// https://github.com/zaphoyd/websocketpp/issues/513
// https://github.com/zaphoyd/websocketpp/issues/181
//
// C++ methods that are used below in the following HTTP callback
// methods are available in the hpp file shown in this URL.
// https://github.com/zaphoyd/websocketpp/blob/master/websocketpp/connection.hpp
// 
// When a client message arrives on a new non_tls HTTP connection, this callback method is run.
void MY_OPERATOR::on_http_message_non_tls(websocketpp::connection_hdl hdl) {
	server_non_tls::connection_ptr server_non_tls_con;
	server_tls::connection_ptr server_tls_con;
	
	// Let us redirect this to the common on_http_message handler by
	// setting the second argument to false to indicate that
	// it is a non_tls HTTP connection from a client.
	bool valid_connection = validate_http_connection(hdl, false,
		server_non_tls_con, server_tls_con);
	
	if (valid_connection == true) {
		on_http_message(hdl, false, server_non_tls_con, server_tls_con);
	}
} // End of on_http_message_non_tls

// When a client message arrives on a new TLS HTTP connection, this callback method is run.
void MY_OPERATOR::on_http_message_tls(websocketpp::connection_hdl hdl) {
	server_non_tls::connection_ptr server_non_tls_con;
	server_tls::connection_ptr server_tls_con;
	
	// Let us redirect this to the common on_http_message handler by
	// setting the second argument to true to indicate that
	// it is a TLS HTTP connection from a client.
	bool valid_connection = validate_http_connection(hdl, true,
		server_non_tls_con, server_tls_con);
	
	if (valid_connection == true) {
		on_http_message(hdl, true, server_non_tls_con, server_tls_con);
	}
} // End of on_http_message_tls

// Validate a new HTTP connection and create a new connection entry in our
// associate container if that connection is acceptable.
bool MY_OPERATOR::validate_http_connection(websocketpp::connection_hdl hdl, 
	bool isTlsConnection,
	server_non_tls::connection_ptr & server_non_tls_con,
	server_tls::connection_ptr & server_tls_con) {
	// Third argument is set to true to indicate that it is a HTTP/S based connection.
	bool valid_connection = validate_client(hdl, isTlsConnection, 
		true, server_non_tls_con, server_tls_con);
	
	if(valid_connection == true) {
		// Mutex for the safe shared accessing of the client connections map.
		SPL::AutoMutex autoMutex3(wsMutex3);
		
		// IMPORTANT NOTE
		// --------------
		// Once we leave from the http handler method below, hdl seems to get reset to NULL.
		// So, we will have a null hdl in the ws_data_sender from where the response will
		// get sent at a later time. That means, we can't rely on hdl to do a deferred 
		// HTTP response when needed. That is why, we store below the con_non_tls or the 
		// con_tls as part of this connection entry so that it can be used in the 
		// ws_data_sender method to send a response later to a given remote HTTP client.
		//
		// Create a new connection entry for this valid HTTP connection.
		// We have to do it this way since HTTP connections are done once for 
		// every message exchange. They don't go through the typical lifecycle of
		// validate, on_open, on_message, on_close handlers that we are vey much 
		// used to with the long running WebSocket connections.
		// Third argument is set to true to indicate that it is a HTTP/S based connection.
		create_new_connection_entry(hdl, isTlsConnection, 
			true, server_non_tls_con, server_tls_con, 
			std::string("validate_http_connection"));
	}
	
	return(valid_connection);
} // End of validate_http_connection

// This is a common on_http_message handler for both the non_tls and TLS client connections.
void MY_OPERATOR::on_http_message(websocketpp::connection_hdl hdl, 
	bool isTlsConnection,
	server_non_tls::connection_ptr & server_non_tls_con,
	server_tls::connection_ptr & server_tls_con) {
	// Mutex for the safe shared accessing of the client connections map.
	SPL::AutoMutex autoMutex3(wsMutex3);
	// Note that we can't use a reference here without assigning it to a proper initial value.
	connection_metadata con_metadata;
	
	try {
		// Get the metadata details for this connection handle from our client connections map.
		con_metadata = get_con_metadata_from_hdl(hdl);
	} catch (const std::invalid_argument & e) {
		if (wsClientSessionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
				"-->Channel " << boost::to_string(udpChannelNumber) << 
				"-->hdl=" << hdl.lock().get() <<
				". Unable to get con_metadata-->" << e.what(), "on_http_message");
		}
		
		return;
	} catch (...) {
		if (wsClientSessionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
				"-->Channel " << boost::to_string(udpChannelNumber) << 
				"-->hdl=" << hdl.lock().get() <<
				". Unable to get con_metadata-->Other exception occurred.", "on_http_message");
		}
		
		return;
	}
	
	bool wsSessionLoggingDone = false;
	
	if (wsClientSessionLoggingNeeded == true) {
		SPLAPPTRC(L_ERROR, "on_http_message called with hdl: " << hdl.lock().get(),
			"on_http_message");
		wsSessionLoggingDone = true;
	}
	
	if (wsSessionLoggingDone == false) {
		SPLAPPTRC(L_INFO, "on_http_message called with hdl: " << hdl.lock().get(),
			"on_http_message");
	}

	// In this variable, get the content type to see if we 
	// received binary data. We expect our HTTP clients to set 
	// the content type HTTP request header as 
	// application/octet-stream when they send us binary data.	
	std::string contentType = "";
	std::string contentLengthString = "";
	std::string httpRequestMethod = "";
	std::string urlQueryString = "";
	
	// Upgrade our connection handle to a full connection_ptr.
	if(isTlsConnection == false) {
		if (server_non_tls_con == NULL) {
			// Not a valid connection. 
			// This seldom happens because of the validation done above in
			// the call chain from where this method is called.
			return;
		}
		
		// Get these HTTP request values that are needed for our initial check.
		contentType = server_non_tls_con->get_request_header("Content-Type");
		contentLengthString = server_non_tls_con->get_request_header("Content-Length");
		httpRequestMethod = server_non_tls_con->get_request().get_method();
		urlQueryString = server_non_tls_con->get_uri()->get_query();
	} else {
		if (server_tls_con == NULL) {
			// Not a valid connection. 
			// This seldom happens because of the validation done above in
			// the call chain from where this method is called.
			return;
		}
		
		// Get these HTTP request values that are needed for our initial check.
		contentType = server_tls_con->get_request_header("Content-Type");
		contentLengthString = server_tls_con->get_request_header("Content-Length");
		httpRequestMethod = server_tls_con->get_request().get_method();
		urlQueryString = server_tls_con->get_uri()->get_query();
	}
	
	// As of June/19/2020, this operator supports only HTTP GET/PUT/POST.
	if(httpRequestMethod != "GET" && 
	   httpRequestMethod != "PUT" &&
	   httpRequestMethod != "POST") {
		// Unsupported HTTP request method.
		// Send a response back to the HTTP client about this.
		if(isTlsConnection == false) {
			try {
				server_non_tls_con->replace_header(std::string("Content-Type"),
					std::string("text/plain"));
				// It is a good practice to send a Connection: close header in the 
				// response when we are not keeping a persistent (Keep-Alive) connection. 
				server_non_tls_con->replace_header(std::string("Connection"),
					std::string("close"));
				server_non_tls_con->set_body(std::string("Your HTTP ") +
					httpRequestMethod + std::string(" request is not supported by ") +
					std::string("the IBM Streams WebSocketSource operator."));
				server_non_tls_con->set_status(websocketpp::http::status_code::method_not_allowed);
			} catch (websocketpp::exception const & e) {
				// Do nothing here.
			}
		} else {
			try {
				server_tls_con->replace_header(std::string("Content-Type"),
					std::string("text/plain"));
				// It is a good practice to send a Connection: close header in the 
				// response when we are not keeping a persistent (Keep-Alive) connection. 
				server_tls_con->replace_header(std::string("Connection"),
					std::string("close"));
				server_tls_con->set_body(std::string("Your HTTP ") +
					httpRequestMethod + std::string(" request is not supported by ") +
					std::string("the IBM Streams WebSocketSource operator."));
				server_tls_con->set_status(websocketpp::http::status_code::method_not_allowed);	
			} catch (websocketpp::exception const & e) {
				// Do nothing here.
			}
		}
		
		// We will go ahead now and do the clean-up of this HTTP connection.
		// HTTP POST client connections are made fresh for every message exchange.
		// So, we are done with this particular HTTP client connection.
		// Delete this client session id from the map that we maintain to do a
		// faster search of a connection handle by using a client session id.
		client_id_to_hdl_map.erase(con_metadata.clientSessionId);

		// Delete this handle from our associative container.        
		client_connections_map.erase(hdl);
		
		// We are now with one less client connection.
		nClientsConnected -= 1;
		
		// Update the operator metric only if the user asked for a live update.
		if (websocketLiveMetricsUpdateNeeded == true) {
			nClientsConnectedMetric->setValueNoLock(nClientsConnected);
		}

		return;
		
		// Please note that unlike in the on_close for WebSocket connections, we are not
		// going to send an End of Client Session" signal on output port 1.
		// Because, it will simply be too many of them for the 
		// HTTP based request/response connections.	
	} // End of if(httpRequestMethod != "GET" && 

	SPL::int32 contentLength = 0;
	contentLength = atoi(contentLengthString.c_str());
	
	// Update the metric counter.
	nHttpMessagesReceivedFromRemoteClients++;
	SPLAPPTRC(L_INFO, nHttpMessagesReceivedFromRemoteClients << 
		") Content-Type=" << contentType << 
		", Content-Length=" << contentLengthString << 
		", hdl=" << hdl.lock().get(), "on_http_message");
	
	// Create an SPL blob type.
	SPL::blob myBlob;
	bool isBinaryData = false;

	// We have a valid message from the remote HTTP client.
	// We support receiving either text based or binary based content via HTTP POST.
	// Let us submit it now on the first output port of this operator.
	// Final argument to our locally implemented data submission method below 
	// carries a string containing all the raw HTTP request headers.	
	if(contentType == "application/octet-stream") {
		// We received a binary based content in the HTTP POST.
		// We expect our HTTP POST clients to use the application/octet-stream
		// content type when they want to send binary data to this operator.
		// Some useful links that explain the use of application/octet-stream to send/receive
		// any arbitrary piece of binary data via HTTP:
		// https://www.iana.org/assignments/media-types/application/octet-stream
		// https://stackoverflow.com/questions/20508788/do-i-need-content-type-application-octet-stream-for-file-download
		// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition
		//
		// NOTE: All my HTTP POST tests of sending/receiving binary data to/from this 
		// operator were done using the streamsx.websocket-->WebSocketSourceWithResponseTester, 
		// streamsx.websocket-->HttpBinarySendToWebSocketSource and the
		// streamsx.websocket-->HttpPostTester examples. In particular, those three examples
		// show how to send binary data with the help of the HttpPost operator invoked 
		// inside their corresponding SPL files. Any standard mechanism available in 
		// Java or other language Web frameworks to do a multipart MIME POST will be able to
		// send/receive binary data to/from this operator in a similar way. Even though,
		// HTTP specification allows for multiple parts (files, images, videos) to be sent
		// together with a uniquely defined boundary signature between them, we only want 
		// the HTTP clients of this operator to send just one binary part with a 
		// unique boundary start line automatically created by the HTTP layer at the very
		// beginning of the request body and the same bounday line appended with -- at 
		// the very end of the request body followed by an empty line. 
		//
		// In this case, our request_body will look somewhat like what is shown below.
		// A beginning boundary identification line, 
		// followed by a Content-Disposition header line with the POST form field name, 
		// followed by an empty line,
		// followed by our binary data of arbitrary length,
		// followed by an ending boundary identification line appended with -- and
		// followed by an empty line.
		//
		/*
		--d7TBeKJHR8KokX3CMCv1SiWowXC6pmX_47t
		Content-Disposition: form-data; name="blobData"

		7b783d313330312c793d312c6f7065726174696f6e3d22616464222c726573756c743d307d
		--d7TBeKJHR8KokX3CMCv1SiWowXC6pmX_47t--
		
		*/
		// Let us get a copy of the request_body from the client's HTTP POST.
		// [What I don't like here is that we are going to do 4 memory copies of
		// this payload within this if block. In the near future, we can see
		// if there is a better way to do this without making that many memory copies.]
		std::string strData = 
			(isTlsConnection == false ? server_non_tls_con->get_request_body() : server_tls_con->get_request_body());

		// We have to parse/tokenize line by line with \n as the token separator.
		// Let us get the empty lines as well to validate if it is 
		// all in the correct format as explained above.
		SPL::list<SPL::rstring> myLines = 
			SPL::Functions::String::tokenize(strData, "\n", true);
		SPL::int32 lineCnt = SPL::Functions::Collections::size(myLines);
		
		// We need a minimum of six lines and the 3rd line and the very last line must be empty.
		// It is important to remove leading/trailing spaces and \r if any 
		// before checking for an empty token for line 3.
		if(lineCnt < 6 || 
		   SPL::Functions::String::trim(myLines[2], " \r") != "" ||
		   SPL::Functions::String::trim(myLines[lineCnt-1], " \r") != "") {
			// The received MIME/binary data format is not correct.
			if(isTlsConnection == false) {
				try {
					server_non_tls_con->replace_header(std::string("Content-Type"),
						std::string("text/plain"));
					// It is a good practice to send a Connection: close header in the 
					// response when we are not keeping a persistent (Keep-Alive) connection. 
					server_non_tls_con->replace_header(std::string("Connection"),
						std::string("close"));
					server_non_tls_con->set_body(std::string("Received an ") + 
						std::string("invalid MIME/Binary data content. ") +
						std::string("Your binary data is not processed and is being ignored."));
					server_non_tls_con->set_status(websocketpp::http::status_code::not_acceptable);
				} catch (websocketpp::exception const & e) {
					// Do nothing here.
				}
			} else {
				try {
					server_tls_con->replace_header(std::string("Content-Type"),
						std::string("text/plain"));
					// It is a good practice to send a Connection: close header in the 
					// response when we are not keeping a persistent (Keep-Alive) connection. 
					server_tls_con->replace_header(std::string("Connection"),
						std::string("close"));
					server_tls_con->set_body(std::string("Received an ") + 
						std::string("invalid MIME/Binary data content. ") +
						std::string("Your binary data is not processed and is being ignored."));
					server_tls_con->set_status(websocketpp::http::status_code::not_acceptable);	
				} catch (websocketpp::exception const & e) {
					// Do nothing here.
				}
			}
			
			// We will go ahead now and do the clean-up of this HTTP connection.
			// HTTP POST client connections are made fresh for every message exchange.
			// So, we are done with this particular HTTP client connection.
			// Delete this client session id from the map that we maintain to do a
			// faster search of a connection handle by using a client session id.
			client_id_to_hdl_map.erase(con_metadata.clientSessionId);

			// Delete this handle from our associative container.        
			client_connections_map.erase(hdl);
			
			// We are now with one less client connection.
			nClientsConnected -= 1;
			
			// Update the operator metric only if the user asked for a live update.
			if (websocketLiveMetricsUpdateNeeded == true) {
				nClientsConnectedMetric->setValueNoLock(nClientsConnected);
			}
			
			return;
			
			// Please note that unlike in the on_close for WebSocket connections, we are not
			// going to send an End of Client Session" signal on output port 1.
			// Because, it will simply be too many of them for the 
			// HTTP based request/response connections.
		} // End of if(lineCnt < 6 || myLines[2] != "" ||

		// Get the binary payload consisting an arbitrary length of data that starts from line 4.
		// We have to take a substring from the beginning of the 4th line to the
		// beginning of the last but one line i.e. the ending boundary identification line.
		//
		// We can get to the beginning of the 4th line by skipping the 
		// first 3 standard multi-part MIME header lines that we already confirmed 
		// in our validation done above. The + 1 you see below is for the \n we 
		// removed during our tokenization done above.
		SPL::int32 idx1 = SPL::Functions::String::length(myLines[0]) + 1 +
			SPL::Functions::String::length(myLines[1]) + 1 +
			SPL::Functions::String::length(myLines[2]) + 1;
		// Get the starting index for the ending boundary identification line.
		// That is the last but one in the token list.
		// lineCnt-1 is the very last token which is an empty line.
		// lineCnt-2 is the ending boundary id line. Every token ends with \r
		// e-g: last but one token="--nFsRWluOYKWw1yv-77pVMf2Ltdee2M1ZkHW41--\r"
		// Our ending boundary id line will end with its own \r\n.
		// As you can see in the e-g: above, that \r is already part of the token.
		// Hence, we have to subtract one more character for the 
		// very last \n with the - 1 below.
		SPL::int32 idx2 = contentLength - 
			SPL::Functions::String::length(myLines[lineCnt-2]) - 1;
        SPL::rstring ending_boundary_id_line = 
        	SPL::Functions::String::substring(strData, idx2, contentLength-idx2);
        
		// Take a substring from idx1 to idx2.
		// Length of that substring should be idx2 - idx1 - 2
		// That - 2 is for the \r\n characters that will be at the end of our binary payload.
		SPL:int32 slen = idx2 - idx1 - 2;
		std::string binary_payload = 
			SPL::Functions::String::substring(strData, idx1, slen);

		if (wsClientSessionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR, nHttpMessagesReceivedFromRemoteClients << 
				") Content-Type=" << contentType << 
				", Content-Length=" << contentLengthString <<
				", lineCnt=" << lineCnt << 
				", binary_payload length=" << binary_payload.length() << 
				", idx1=" << idx1 <<
				", idx2=" << idx2 <<
				", first token=" << myLines[0] << 
				", second token=" << myLines[1] << 
				", last but one token=" << myLines[lineCnt-2] << 
				", ending_boundary_id_line=" << ending_boundary_id_line <<
				", slen=" << slen <<
				", hdl=" << hdl.lock().get(), "on_http_message");
		}
		
		// In WebSocket++, payload is in std::string format for both
		// text and binary data. So, we can get the binary buffer from
		// that string payload. This idea is discussed in this URL:
		// https://github.com/zaphoyd/websocketpp/issues/412
		//
		// This transfers (copies) the payload buffer into the 
		// internal buffer held by the blob. 
		// The blob owns the copied data in memory.
		myBlob.setData((unsigned char*)binary_payload.data(), (uint64_t)slen);
		// We got our blob data. We can empty the strData to indicate that 
		// the data being sent is not string based.
		strData = "";
		isBinaryData = true;
		submit_received_data_item(isBinaryData, contentLength, strData, myBlob, 
			hdl, con_metadata, httpRequestMethod, urlQueryString, 
			(isTlsConnection == false ? server_non_tls_con->get_request().raw_head() : server_tls_con->get_request().raw_head()));		
	} else {
		// We received a text based content in the HTTP POST.
		submit_received_data_item(isBinaryData, contentLength,
			(isTlsConnection == false ? server_non_tls_con->get_request_body() : server_tls_con->get_request_body()),
			myBlob, hdl, con_metadata, httpRequestMethod, urlQueryString, 
			(isTlsConnection == false ? server_non_tls_con->get_request().raw_head() : server_tls_con->get_request().raw_head()));
	}
	
	if (wsClientSessionLoggingNeeded == true) {
		SPLAPPTRC(L_ERROR,
			"Operator "
			<< operatorPhysicalName
			<< "-->Channel " << boost::to_string(udpChannelNumber)
			<< "-->X8 Received data from a remote HTTP client "
			<< "and sent it via an output tuple. "
			<< "clientSessionId=" << con_metadata.clientSessionId
			<< ", hdl=" << con_metadata.hdl.lock().get()
			<< ", remoteEndpoint=" << con_metadata.remoteEndpoint
			<< ", clientIp=" << con_metadata.clientIpAddress
			<< ", clientPort=" << con_metadata.clientPort
			<< ", isTlsConnection=" << con_metadata.isTlsConnection
			<< ", isHttpConnection=" << con_metadata.isHttpConnection
			<< ", serverIp=" << con_metadata.serverIpAddress
			<< ", serverPort=" << con_metadata.serverPort
			<< ", contentType=" << contentType
			<< ", currentDataPacketSize=" << contentLength
			<< ", dataItemsReceivedCnt=" << con_metadata.dataItemsReceivedCnt
			<< ", dataBytesReceived=" << con_metadata.dataBytesReceived		
			<< ", HTTP messages received from all clients=" << nHttpMessagesReceivedFromRemoteClients 
			<< ", nClientsConnected=" << nClientsConnected
			<< ", total data items received from all clients=" << nDataItemsReceivedFromRemoteClients
			<< ", total data bytes received from all clients=" << nDataBytesReceivedFromRemoteClients,
			"on_http_message");
	}
		
	// The following block can be used to display the HTTP request headers and the message body.
	// You may want to change the log level to L_ERROR, test it and then put it back to L_DEBUG.
	if (wsSessionLoggingDone == false) {
		SPLAPPTRC(L_DEBUG, "Operator " << operatorPhysicalName 
			<< "-->Channel " << boost::to_string(udpChannelNumber) 
			<< "-->X9 Received data from a remote HTTP client"
			<< ", clientSessionId=" << con_metadata.clientSessionId 
			<< ", hdl=" << con_metadata.hdl.lock().get() 
			<< ", remoteEndpoint=" << con_metadata.remoteEndpoint
			<< ", clientIp=" << con_metadata.clientIpAddress
			<< ", clientPort=" << con_metadata.clientPort
			<< ", isTlsConnection=" << con_metadata.isTlsConnection
			<< ", isHttpConnection=" << con_metadata.isHttpConnection
			<< ", serverIp=" << con_metadata.serverIpAddress
			<< ", serverPort=" << con_metadata.serverPort
			<< ", contentType=" << contentType
			<< ", currentDataPacketSize=" << contentLength
			<< ", dataItemsReceivedCnt=" << con_metadata.dataItemsReceivedCnt
			<< ", dataBytesReceived=" << con_metadata.dataBytesReceived	
			<< ", HTTP messages received from all clients=" << nHttpMessagesReceivedFromRemoteClients 
			<< ", nClientsConnected=" << nClientsConnected
			<< ", total data items received from all clients=" << nDataItemsReceivedFromRemoteClients
			<< ", total data bytes received from all clients=" << nDataBytesReceivedFromRemoteClients		
			<< ", HTTP Request Headers=" 
			<< (isTlsConnection == false ? server_non_tls_con->get_request().raw_head() : server_tls_con->get_request().raw_head()) 
			<< ", HTTP Body=" 
			<< (isTlsConnection == false ? server_non_tls_con->get_request_body() : server_tls_con->get_request_body()), 
			"on_http_message");
	}

	// We can send a response back to the client only when this
	// operator is functioning as a pure source operator.
	// If this operator is configured with a "data result/response to client"
	// input port, then we can't send a response at this time.
	// Instead, the data item we just now received from a remote HTTP client
	// will be sent to the application layer first, it will get processed and then
	// the application layer will send a response back to that client on its own.
	// That kind of "response back to the HTTP client" done by the application layer is
	// sent in the ws_data_sender method above in this operator class.
	<% if (!defined($dataResponseToClientPortFound)) { %>
	// Send a response back to the HTTP client.
	if(isTlsConnection == false) {
		try {
			server_non_tls_con->replace_header(std::string("Content-Type"),
				std::string("text/plain"));
			// It is a good practice to send a Connection: close header in the 
			// response when we are not keeping a persistent (Keep-Alive) connection. 
			server_non_tls_con->replace_header(std::string("Connection"),
				std::string("close"));
			std::string response_text = 
				std::string("Received ") + contentLengthString + 
				std::string(" byte(s) of your data via a non-persistent, non-TLS HTTP ") + 
				httpRequestMethod + std::string(" connection.");
			server_non_tls_con->set_body(response_text);
			
			/*
			// This is redundant. Boost ASIO server will always add this header in the response.
			// Add a content-length header.
			server_non_tls_con->replace_header("Content-Length", 
				boost::to_string(response_text.length()));
			*/
			
			// Set the HTTP response code.
			server_non_tls_con->set_status(websocketpp::http::status_code::ok);
		} catch (websocketpp::exception const & e) {
			// Do nothing here.
		}
	} else {
		try {
			server_tls_con->replace_header(std::string("Content-Type"),
				std::string("text/plain"));
			// It is a good practice to send a Connection: close header in the 
			// response when we are not keeping a persistent (Keep-Alive) connection. 
			server_tls_con->replace_header(std::string("Connection"),
				std::string("close"));
			std::string response_text = 
				std::string("Received ") + contentLengthString + 
				std::string(" byte(s) of your data via a non-persistent, TLS HTTP ") + 
				httpRequestMethod + std::string(" connection.");
			server_tls_con->set_body(response_text);
			
			/*
			// This is redundant. Boost ASIO server will always add this header in the response.
			// Add a content-length header.
			server_tls_con->replace_header("Content-Length", 
				boost::to_string(response_text.length()));
			*/
			
			// Set the HTTP response code.
			server_tls_con->set_status(websocketpp::http::status_code::ok);	
		} catch (websocketpp::exception const & e) {
			// Do nothing here.
		}
	}
	
	// If this operator has the "result/response back to the client" input port,
	// then we are not going to erase this HTTP connection now. That activity
	// will be done later when the response gets sent or if a response timeout occurs.
	//
	// If there is no "result/response back to the client" input port present,
	// we will go ahead now and do the clean-up of this HTTP connection.
	// HTTP POST client connections are made fresh for every message exchange.
	// So, we are done with this particular HTTP client connection.
	// Delete this client session id from the map that we maintain to do a
	// faster search of a connection handle by using a client session id.
	client_id_to_hdl_map.erase(con_metadata.clientSessionId);

	// Delete this handle from our associative container.        
	client_connections_map.erase(hdl);
	
	// We are now with one less client connection.
	nClientsConnected -= 1;
	
	// Update the operator metric only if the user asked for a live update.
	if (websocketLiveMetricsUpdateNeeded == true) {
		nClientsConnectedMetric->setValueNoLock(nClientsConnected);
	}
	
	// Please note that unlike in the on_close for WebSocket connections, we are not
	// going to send an End of Client Session" signal on output port 1.
	// Because, it will simply be too many of them for the 
	// HTTP based request/response connections.
	<%} else {%>
	// We are going to defer the response for this HTTP client until at a later time.
	// The received data item here will get processed by the application logic and
	// the application logic will send a response to this client via the 
	// result/response back to the client" input port. Please look inside the
	// ws_data_sender in in the response_timeout_handler methods.
	// The core idea of deferring a HTTP response is explained in these URLs:
	// https://github.com/zaphoyd/websocketpp/issues/425
	// https://www.zaphoyd.com/websocketpp/manual/reference/handler-list/httphandler
	//
	// IMPORTANT NOTE
	// --------------
	// Once we leave from this handler method, hdl seems to get reset to NULL.
	// So, we will have a null hdl in the ws_data_sender from where the response will
	// get sent at a later time. That means, we can't rely on hdl to do a deferred 
	// HTTP response when needed. That is why, we stored the con_non_tls or the 
	// con_tls as part of this connection entry at the time of creating this 
	// HTTP connection so that it can be used in the ws_data_sender method to send 
	// a response later to a given remote HTTP client.
	if(isTlsConnection == false) {
		websocketpp::lib::error_code ec = server_non_tls_con->defer_http_response();
	} else {
		websocketpp::lib::error_code ec = server_tls_con->defer_http_response();
	}
	<%}%>	
} // End of on_http_message

// This is an utility method to get the client connection meta data for a given connection handle.
MY_OPERATOR::connection_metadata & MY_OPERATOR::get_con_metadata_from_hdl(
	websocketpp::connection_hdl hdl) {
	auto it = client_connections_map.find(hdl);

	if (it == client_connections_map.end()) {
		std::ostringstream errorStringStream;
		errorStringStream
			<< "No connection metadata avaliable for a given connection handle: "
			<< hdl.lock().get();
		std::string error_string =
			errorStringStream.str();
		// This connection is not in the map. This really shouldn't happen
		// and probably means something else is wrong.
		throw std::invalid_argument(error_string.c_str());
	}

	// it->first has the key of the map and it->second has the value.
	return it->second;
} // End of get_con_metadata_from_hdl

// This is an utility method to get the client connection meta data for a given connection handle.
MY_OPERATOR::connection_metadata & MY_OPERATOR::get_con_metadata_from_client_id(
	uint64_t client_id) {
	// Get the connection handle for a given client id.
	auto it = client_id_to_hdl_map.find(client_id);
	
	if (it == client_id_to_hdl_map.end()) {
		std::ostringstream errorStringStream;
		errorStringStream
			<< "No connection handle avaliable for a given client id: "
			<< client_id;
		std::string error_string =
			errorStringStream.str();
		// This connection handle is not in the map. This really shouldn't happen
		// and probably means something else is wrong.
		throw std::invalid_argument(error_string.c_str());
	}
	
	// it->first has the key of the map and it->second has the value.
	return(get_con_metadata_from_hdl(it->second));
} // End of get_con_metadata_from_client_id

// This method creates a new connection entry in our associative container.
// Such a new connection could either be WebSocket or HTTP based.
// This method will be called from the on_open handler for 
// WebSocket connections and from the validate_http_connection handler for
// HTTP connections.
bool MY_OPERATOR::create_new_connection_entry(
	websocketpp::connection_hdl hdl, bool isTlsConnection, 
	bool isHttpConnection, server_non_tls::connection_ptr & con_non_tls,
	server_tls::connection_ptr & con_tls, std::string callerIdentifier) {
	bool wsSessionLoggingDone = false;

	if (wsClientSessionLoggingNeeded == true) {
		SPLAPPTRC(L_ERROR, callerIdentifier << " called for hdl: " << 
			hdl.lock().get(), callerIdentifier);
		wsSessionLoggingDone = true;
	}

	if (wsSessionLoggingDone == false) {
		SPLAPPTRC(L_INFO, callerIdentifier << " called for hdl: " << 
			hdl.lock().get(), callerIdentifier);
	}

	// Add this newly opened client connection to the associative container.
	connection_metadata con_metadata;
	con_metadata.isTlsConnection = isTlsConnection;
	con_metadata.isHttpConnection = isHttpConnection;
	con_metadata.hdl = hdl;
	// IMPORTANT NOTE
	// --------------
	// Once we leave from the http handler method above, hdl seems to get reset to NULL.
	// So, we will have a null hdl in the ws_data_sender from where the response will
	// get sent at a later time. That means, we can't rely on hdl to do a deferred 
	// HTTP response when needed. That is why, we store below the con_non_tls or the 
	// con_tls as part of this connection entry so that it can be used in the 
	// ws_data_sender method to send a response later to a given remote HTTP client.
	con_metadata.http_con_non_tls = con_non_tls;
	con_metadata.http_con_tls = con_tls;
	con_metadata.wsSessionStatus = CLIENT_OPENED_A_WS_CONNECTION;
	con_metadata.wsSessionStartTime = SPL::Functions::Time::getSeconds(
		SPL::Functions::Time::getTimestamp());
	// No response is due for this client at this time.
	con_metadata.responseTimeoutCounter = -1;
	con_metadata.dataItemsReceivedCnt = 0;
	con_metadata.dataBytesReceived = 0;
	con_metadata.dataItemsSentCnt = 0;
	con_metadata.dataBytesSent = 0;
	con_metadata.clientSessionId = ++clientSessionId;
	
	// This con_metadata is only partial with no clientIpAddress and clientPort fields set correctly.
	// We will set those fields in the code block right below here.
	client_connections_map[hdl] = con_metadata;
	// Let us store the connection handle in another map for a faster
	// search using client session id when we have to send a 
	// data item back to a particular client.
	client_id_to_hdl_map[clientSessionId] = hdl;
	
	// Update this client connection for the metric reporting.
	nClientsConnected++;
	
	// Update the operator metric only if the user asked for a live update.
	if (websocketLiveMetricsUpdateNeeded == true) {
		nClientsConnectedMetric->setValueNoLock(nClientsConnected);
	}		
	
	// Let us log that this remote client opened a connection.
	// We will make our best attempt here to log it.
	// If we encounter any errors as shown below, we can return since
	// not being able to log is not a major concern at this point in this method.
	// Having said that, a possibility of an error happening in the logic below is
	// extremely rare.
	std::string remoteEndpoint = "";
	std::string serverIp = "";
	std::string serverPort = "";
	std::string clientIp = "";
	std::string clientPort = "";
	std::string myUrlContext = "";
	std::string httpRequestMethod = "";
	std::string fullUrl = "";

	if (isTlsConnection == false) {
		if(con_non_tls == NULL) {
			if (wsConnectionLoggingNeeded == true) {
				SPLAPPTRC(L_ERROR, 
					"[create_new_connection_entry for " << callerIdentifier <<
					"] Connection pointer is NULL for the non_tls connection handle. " <<
					"hdl=" << hdl.lock().get(), callerIdentifier);
			}
			
			// We have only done a partial connection entry.
			return(false);
		}
		
		remoteEndpoint = con_non_tls->get_remote_endpoint();
		serverIp = con_non_tls->get_host();
		serverPort = boost::to_string(con_non_tls->get_port());
		// Get the context path present in the URL being accessed by this client.
		myUrlContext = con_non_tls->get_resource();
		// Get the HTTP request method and the full URL.
		httpRequestMethod = con_non_tls->get_request().get_method();
		
		if(isHttpConnection == false) {
			fullUrl = "ws://";
		} else {
			fullUrl = "http://";
		}
	} else {
		if(con_tls == NULL) {
			if (wsConnectionLoggingNeeded == true) {
				SPLAPPTRC(L_ERROR, 
					"[create_new_connection_entry for " << callerIdentifier <<
					"] Connection pointer is NULL for the TLS connection handle. " <<
					"hdl=" << hdl.lock().get(), callerIdentifier);
			}
			
			// We have only done a partial connection entry.
			return(false);
		}
		
		remoteEndpoint = con_tls->get_remote_endpoint();
		serverIp = con_tls->get_host();
		serverPort = boost::to_string(con_tls->get_port());	
		// Get the context path present in the URL being accessed by this client.
		myUrlContext = con_tls->get_resource();
		// Get the HTTP request method and the full URL.
		httpRequestMethod = con_tls->get_request().get_method();

		if(isHttpConnection == false) {
			fullUrl = "wss://";
		} else {
			fullUrl = "https://";
		}
	}
	
	// Complete the forming of the full URL.
	fullUrl += serverIp + ":" + serverPort + myUrlContext;
	
	// In my tests, I have seen two different forms of values returned for remoteEndpoint. 
	// We should be prepared to deal with both of those formats.
	// [::ffff:10.6.33.13]:46772        [When ipv6Available operator parameter is set to true]
	// 10.6.33.17:52186                 [When ipv6Available operator parameter is set to false]
	// From that result string, let us parse the client IP and client port.
	SPL::list<SPL::rstring> tokens = 
		SPL::Functions::String::tokenize(remoteEndpoint, ":", true);
	
	if(SPL::Functions::Collections::size(tokens) != 5 &&
	   SPL::Functions::Collections::size(tokens) != 2) {
		// We don't have the correct number of tokens.
		if (wsConnectionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR, 
				"Unable to find all the fileds in the remoteEndpoint result. " <<
				"remoteEndpoint=" << remoteEndpoint <<
				", hdl=" << hdl.lock().get(), callerIdentifier);
		}
		
		// We have only done a partial connection entry.
		return(false);		
	}
	
	if(SPL::Functions::Collections::size(tokens) == 5) {
		// This is in ipv6 format.
		// 4th token has the client IP and the 5th token has the client port.
		clientIp = tokens[3];
		// Trim the last character ']' from the clientIp.
		clientIp = SPL::Functions::String::rtrim(clientIp, std::string("]"));
		clientPort = tokens[4];
	} else {
		// This is in ipv4 format.
		// 1st token has the client IP and the 2nd token has the client port.
		clientIp = tokens[0];
		clientPort = tokens[1];
	}

	// In the url context path, remove the leading forward slash.
	myUrlContext = SPL::Functions::String::ltrim(myUrlContext, "/");
	// If it is a HTTP GET URL, there may be a query string present.
	// Remove the query string part.
	SPL::int32 idx1 = SPL::Functions::String::findFirst(myUrlContext, "?");
	
	if (idx1 != -1) {
		// Query string is present.
		// Get rid of the query string part by taking a substring.
		myUrlContext = SPL::Functions::String::substring(myUrlContext, 0, idx1);
	}

	SPL::int32 numberOfContextPaths = SPL::Functions::Collections::size(urlContextPath);
	SPL::rstring fileNameInUrlForHttpGet = "";
	
	// If it is HTTP GET, it is possible thst the client is requesting a file such as 
	// index.html, image.png etc. In that case, URL will look like this.
	// http://b0513:8080/MyServices/Banking/Deposit/index.html?NY=Albany&CT=Hartford&NJ=Trenton&RI=Providence
	// https://b0513:8443/MyServices/Banking/Deposit/pics/image.jpg
	//
	// We can now loop through the URL context path list and check if we have a
	// HTTP GET based URL with a file name.
	for(SPL::int32 cnt = 0; cnt < numberOfContextPaths; cnt++) {
		if(httpRequestMethod == "GET" && urlContextPath[cnt] != "" && 
		   SPL::Functions::String::findFirst(myUrlContext, (urlContextPath[cnt])) == 0) {
			// This HTTP GET based URL definitely has the required context plus more.
			// That more stuff could be the file name whose contents are being requested by the remote client.
			// e-g: index.html, image.gif etc.
			SPL::int32 urlContextLength = SPL::Functions::String::length(urlContextPath[cnt]);
			SPL::int32 fileNameLength = SPL::Functions::String::length(myUrlContext) - urlContextLength;
			
			if(fileNameLength > 0) {
				fileNameInUrlForHttpGet = 
					SPL::Functions::String::substring(myUrlContext, urlContextLength, fileNameLength);
				// Get just the URL context without the presence of  the file name in the GET based URL.
				myUrlContext = 
					SPL::Functions::String::substring(myUrlContext, 0, urlContextLength);
			}
			
			break;
		}
		
		// If it is HTTP GET, it is possible thst the client is requesting a file such as 
		// favicon.ico. In that case, URL will look like this.
		// https://b0513:8443/favicon.ico
		// In such cases, let us allow this remote HTTP client to go through if the user has
		// configured "" as one of the permitted URL context paths.
		if(httpRequestMethod == "GET" && urlContextPath[cnt] == "" && 
		   SPL::Functions::String::findFirst(myUrlContext, urlContextPath[cnt]) == 0) {
			// This HTTP GET based URL definitely has the required context plus more.
			// That more stuff could be the file name whose contents are being requested by the remote client.
			// e-g: favicon.ico
			SPL::int32 urlContextLength = SPL::Functions::String::length(urlContextPath[cnt]);
			SPL::int32 fileNameLength = SPL::Functions::String::length(myUrlContext) - urlContextLength;
			
			if(fileNameLength > 0) {
				// In this path of the logic, we have an empty URL context path.
				// So, let us add a leading forward slash to the file name which will be
				// needed for the downstream operators to properly open that file by
				// concatenating the file name with the actual context base directory name.
				fileNameInUrlForHttpGet = std::string("/") + 
					SPL::Functions::String::substring(myUrlContext, urlContextLength, fileNameLength);
				// Get just the URL context without the presence of  the file name in the GET based URL.
				myUrlContext = 
					SPL::Functions::String::substring(myUrlContext, 0, urlContextLength);
			}
			
			break;
		}
	} // End of for loop.

	// Update the clientIpAddress, clientPort and related fields.
	con_metadata.remoteEndpoint = remoteEndpoint;
	con_metadata.clientIpAddress =  clientIp;
	con_metadata.clientPort = clientPort;
	con_metadata.urlContextPath = myUrlContext;
	con_metadata.serverIpAddress =  serverIp;
	con_metadata.serverPort = serverPort;
	con_metadata.fullUrl = fullUrl;
	con_metadata.fileNameInUrlForHttpGet = fileNameInUrlForHttpGet;
	client_connections_map[hdl] = con_metadata;
	
	if (wsConnectionLoggingNeeded == true) {
		SPLAPPTRC(L_ERROR, 
			"Operator " <<
			operatorPhysicalName <<
			"-->Channel " << boost::to_string(udpChannelNumber) <<
			". This remote client connected. " <<
			"clientSessionId=" << con_metadata.clientSessionId <<
			", hdl=" << hdl.lock().get() <<
			", remoteEndpoint=" << remoteEndpoint <<
			", clientIp=" << clientIp <<
			", clientPort=" << clientPort <<
			", urlContextPath=" << myUrlContext <<
			", isTlsConnection=" << isTlsConnection <<
			", isHttpConnection=" << isHttpConnection <<
			", serverIp=" << serverIp <<
			", serverPort=" << serverPort <<
			", nClientsConnected=" << nClientsConnected << 
			", maxClientConnectionsAllowed=" << maxClientConnectionsAllowed,
			callerIdentifier);	
	} // End of if (wsConnectionLoggingNeeded == true)
	
	return(true);
} // End of create_new_connection_entry

// This method submits the text or binary data item received from a 
// remote WS or HTTP client into the first output port of this operator.
void MY_OPERATOR::submit_received_data_item(bool & isBinaryData, int32_t & payloadSize,
	std::string const & strData, SPL::blob & blobData, 
	websocketpp::connection_hdl & hdl,
	MY_OPERATOR::connection_metadata & con_metadata,
	std::string const & httpRequestMethod, 
	std::string const & urlQueryString,
	std::string const & httpRequestHeaders) {
	OPort0Type oTuple;
	
	<%if (defined($dataOutputAsRString)) {%>
	if(isBinaryData == false) {
		oTuple.set_strData(strData);
	}
	<%}%>

	<%if (defined($dataOutputAsBlob)) {%>
	if(isBinaryData == true) {
		oTuple.set_blobData(blobData);
	}
	<%}%>
	
	// Update some of the counters that we maintain in the con_metadata.
	con_metadata.dataItemsReceivedCnt++;
	con_metadata.dataBytesReceived += payloadSize;
	
	<% if (defined($dataResponseToClientPortFound)) { %>
		// If this operator is configured with a "result/response back to client" input port,
		// then we have to start the response timeout counter now by setting it to a
		// value of 0. Response timeout counter starts now. It will get reset back to -1
		// either inside the ws_data_sender method when a response is sent to this client or
		// when a response timeout occurs in the ws_response_timeout_handler.
		con_metadata.responseTimeoutCounter = 0;
	<%}%>
	
	// Update it in the client connections map.
	client_connections_map[hdl] = con_metadata;
	nDataItemsReceivedFromRemoteClients++;
	nDataBytesReceivedFromRemoteClients += payloadSize;
	
	// Now let us set any attributes that the caller of this operator is trying to
	// assign through this operator's output functions.
	<%
	my $oport = $model->getOutputPortAt(0);
	foreach my $attribute(@ { $oport->getAttributes() }) {
		my $name = $attribute->getName();
		my $paramValues =
			$attribute->getAssignmentOutputFunctionParameterValues();
		my $operation =
			$attribute->getAssignmentOutputFunctionName();

		if ($operation eq "getClientSessionId") { 					  
		%> 
			// Send the current clientSessionId.
			oTuple.set_<%=$name%>(<%=$operation%>(con_metadata.clientSessionId));
		<%} elsif ($operation eq "getClientIpAddress") {
		%>
			// Send the client's IP address.
			oTuple.set_<%=$name%>(<%=$operation%>(con_metadata.clientIpAddress));
		<%} elsif ($operation eq "getClientPort") {
		%>
			// Send the client's port.
			oTuple.set_<%=$name%>(<%=$operation%>(con_metadata.clientPort));
		<%} elsif ($operation eq "getUrlContextPath") {
		%>
			// Send the context path present in the URL being accessed by the client.
			oTuple.set_<%=$name%>(<%=$operation%>(con_metadata.urlContextPath));		
		<%} elsif ($operation eq "isWebSocketClient") {
		%>
			// Send an indication abbout whether it is a WebSocket client.
			bool wsClientStatus = con_metadata.isHttpConnection == true ? false : true;
			oTuple.set_<%=$name%>(<%=$operation%>(wsClientStatus));
		<%} elsif ($operation eq "isHttpClient") {
		%>
			// Send an indication abbout whether it is a Http client.
			oTuple.set_<%=$name%>(<%=$operation%>(con_metadata.isHttpConnection));
		<%} elsif ($operation eq "getTotalDataItemsReceived") {
		%>
			// All the metrics offered below are for a given client session id.
			// We don't expose the global metrics to the application layer.
			// Global metrics for this operator can only be viewed from the 
			// IBM Streams web console or queried via REST/JMX APIs.
			oTuple.set_<%=$name%>(<%=$operation%>(con_metadata.dataItemsReceivedCnt));
		<%} elsif ($operation eq "getTotalDataBytesReceived") {
		%>
			oTuple.set_<%=$name%>(<%=$operation%>(con_metadata.dataBytesReceived));
		<%} elsif ($operation eq "getTotalDataItemsSent") {
		%>
			oTuple.set_<%=$name%>(<%=$operation%>(con_metadata.dataItemsSentCnt));
		<%} elsif ($operation eq "getTotalDataBytesSent") {
		%>
			oTuple.set_<%=$name%>(<%=$operation%>(con_metadata.dataBytesSent));
		<%} elsif ($operation eq "getHttpRequestMethodName") {
		%>
			oTuple.set_<%=$name%>(<%=$operation%>(httpRequestMethod));
		<%} elsif ($operation eq "getUrlQueryStringKeyValuePairs") {
		%>
			oTuple.set_<%=$name%>(<%=$operation%>(urlQueryString));
		<%} elsif ($operation eq "getFullUrlBeingAccessedByTheClient") {
		%>
			oTuple.set_<%=$name%>(<%=$operation%>(con_metadata.fullUrl));
		<%} elsif ($operation eq "getFileNameInUrlForHttpGet") {
		%>
			oTuple.set_<%=$name%>(<%=$operation%>(con_metadata.fileNameInUrlForHttpGet));
		<%} elsif ($operation eq "getHttpRequestHeaders") {
		%>
			oTuple.set_<%=$name%>(<%=$operation%>(httpRequestHeaders));
		<%}
	}%>

	// Submit the output tuple.
	submit(oTuple, 0);

	// Update the operator metric only if the user asked for a live update.
	if (websocketLiveMetricsUpdateNeeded == true) {
		nDataItemsReceivedFromRemoteClientsMetric->setValueNoLock(nDataItemsReceivedFromRemoteClients);
		nDataBytesReceivedFromRemoteClientsMetric->setValueNoLock(nDataBytesReceivedFromRemoteClients);
		nHttpMessagesReceivedFromRemoteClientsMetric->setValueNoLock(nHttpMessagesReceivedFromRemoteClients);
		nSizeOfMostRecentDataItemReceivedMetric->setValueNoLock(payloadSize);
	}			
} // End of submit_received_data_item

// WebSocketSource Output Functions that are needed to set the output tuple attributes with their values.
uint64_t MY_OPERATOR::getClientSessionId(uint64_t const & clientSessionId) {
	return(clientSessionId);
}

std::string MY_OPERATOR::getClientIpAddress(std::string const & clientIpAddress) {
	return clientIpAddress;
}

std::string MY_OPERATOR::getClientPort(std::string const & clientPort) {
	return clientPort;
}

std::string MY_OPERATOR::getUrlContextPath(std::string const & urlContextPath) {
	return urlContextPath;
}

bool MY_OPERATOR::isWebSocketClient(bool const & isWebSocketConnection) {
	return isWebSocketConnection;
}

bool MY_OPERATOR::isHttpClient(bool const & isHttpConnection) {
	return isHttpConnection;
}

uint64_t MY_OPERATOR::getTotalDataItemsReceived(uint64_t const & totalDataItemsReceived) {
	return (totalDataItemsReceived);
}

uint64_t MY_OPERATOR::getTotalDataBytesReceived(uint64_t const & totalDataBytesReceived) {
	return (totalDataBytesReceived);
}

uint64_t MY_OPERATOR::getTotalDataItemsSent(uint64_t const & totalDataItemsSent) {
	return (totalDataItemsSent);
}

uint64_t MY_OPERATOR::getTotalDataBytesSent(uint64_t const & totalDataBytesSent) {
	return (totalDataBytesSent);
}

std::string MY_OPERATOR::getHttpRequestMethodName(std::string const & httpRequestMethodName) {
	return httpRequestMethodName;
}

SPL::map<SPL::rstring, SPL::rstring> MY_OPERATOR::getUrlQueryStringKeyValuePairs(
	std::string const & urlQueryString) {
	SPL::map<SPL::rstring, SPL::rstring> myMap;
	
	// If a url query string with no Key/Value pairs was sent to 
	// this method, return an empty map.
	if(urlQueryString == "") {
		return(myMap);
	}
	
	/*
	We have to simply parse the KV pairs separated by & and
	then split the key and value parts to be inserted into the map.
	
	Following is a sample of a query string.
	NY=Albany&CT=Hartford&NJ=Trenton&RI=Providence
	*/	

	// A URL query string always appears in a single string as shown above.
	SPL::list<SPL::rstring> myKVPairs = 
		SPL::Functions::String::tokenize(urlQueryString, "&", false);
	SPL::int32 kvPairsCnt = SPL::Functions::Collections::size(myKVPairs);
	
	if(kvPairsCnt == 0) {
		// There are no KV pairs here.
		return(myMap);
	}
	
	// We can split the individual KV pairs and push them into
	// the map that we will return from this method.	
	for(SPL::int32 cnt = 0; cnt < kvPairsCnt; cnt++) {
		// As shown above, every KV pair has a "key=value" format.
		SPL::list<SPL::rstring> keyValue = 
			SPL::Functions::String::tokenize(myKVPairs[cnt], "=", false);
		
		if(SPL::Functions::Collections::size(keyValue) != 2) {
			// Not a valid KV pair. Continue to the next one.
			//
			// Use the following print line if debugging of the skipped KV pairs is needed.
			// std::cout << "Skipping this KV pair: " << myKVPairs[cnt] << std::endl;
			//
			continue;
		}
		
		// Insert them in our map.
		// Remove any leading and trailing spaces in them.
		SPL::Functions::Collections::insertM(
			myMap,
			SPL::Functions::String::trim(keyValue[0], " "), 
			SPL::Functions::String::trim(keyValue[1], " "));
	}
	
	return(myMap);	
}

SPL::map<SPL::rstring, SPL::rstring> MY_OPERATOR::getHttpRequestHeaders(
	std::string const & httpRequestHeaders) {
	SPL::map<SPL::rstring, SPL::rstring> myMap;
	
	// If no headers were sent to this method, return an empty map.
	if(httpRequestHeaders == "") {
		return(myMap);
	}
	
	/*
	Following is a sample of different lines of HTTP request headers in the
	string argument of this method.
	
	POST / HTTP/1.1^M
	Accept-Encoding: gzip,deflate^M
	Author: Peter Pan^M
	connection: keep-alive^M
	Content-Length: 12131^M
	Content-Type: text/plain^M
	Host: b0513:8080^M
	Location: Yorktown Heights, NY, USA^M
	Organization: IBM Research^M
	Streams-Application-Name: HttpPostTester^M
	User-Agent: Apache-HttpClient/4.3.6 (java 1.5)^M
	*/
	
	// HTTP headers always appear one per line as shown above.
	SPL::list<SPL::rstring> myHeaders = 
		SPL::Functions::String::tokenize(httpRequestHeaders, "\n", false);
	SPL::int32 headersCnt = SPL::Functions::Collections::size(myHeaders);
	
	if(headersCnt == 0) {
		// There are no headers here.
		return(myMap);
	}
	
	// We can parse the individual headers and push them into
	// the map that we will return from this method.	
	for(SPL::int32 cnt = 0; cnt < headersCnt; cnt++) {
		// As shown above, every HTTP header line has a "key: value" format.
		SPL::list<SPL::rstring> keyValue = 
			SPL::Functions::String::tokenize(myHeaders[cnt], ":", false);
		
		if(SPL::Functions::Collections::size(keyValue) != 2) {
			// Not a valid header. Continue to the next one.
			//
			// Use the following print line if debugging of the skipped HTTP headers is needed.
			// std::cout << "Skipping this HTTP header: " << myHeaders[cnt] << std::endl;
			//
			continue;
		}
		
		// Insert them in our map.
		// Remove any leading and trailing spaces and \r in them.
		// HTTP headers are always one per line where each line
		// ends with a new line character ^M which could be \n (OR) \r\n
		SPL::Functions::Collections::insertM(
			myMap,
			SPL::Functions::String::trim(keyValue[0], " \r"), 
			SPL::Functions::String::trim(keyValue[1], " \r"));
	}
	
	return(myMap);
}

std::string MY_OPERATOR::getFullUrlBeingAccessedByTheClient(std::string const & fullUrl) {
	return(fullUrl);
}

std::string MY_OPERATOR::getFileNameInUrlForHttpGet(std::string const & fileNameInUrl) {
	return(fileNameInUrl);
}

<%SPL::CodeGen::implementationEpilogue($model);%>
